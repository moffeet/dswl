# ğŸ“‹ ç­¾æ”¶å•ç®¡ç†æ¨¡å—å®ç°è¯¦è§£

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

ç­¾æ”¶å•ç®¡ç†æ¨¡å—è´Ÿè´£å¤„ç†ç‰©æµé…é€è¿‡ç¨‹ä¸­çš„ç­¾æ”¶å•æ®ç®¡ç†ï¼ŒåŒ…æ‹¬å›¾ç‰‡ä¸Šä¼ ã€åœ°ç†ä½ç½®è®°å½•ã€ç­¾æ”¶ä¿¡æ¯ç®¡ç†ç­‰åŠŸèƒ½ã€‚æ”¯æŒå¤šç§æ–‡ä»¶æ ¼å¼ä¸Šä¼ å’Œè‡ªåŠ¨å›¾ç‰‡å‹ç¼©å¤„ç†ã€‚

## ğŸ—ï¸ æ¨¡å—æ¶æ„

### ç›®å½•ç»“æ„
```
backend-node/src/receipts/
â”œâ”€â”€ receipts.controller.ts      # ç­¾æ”¶å•æ§åˆ¶å™¨
â”œâ”€â”€ receipts.service.ts         # ç­¾æ”¶å•æœåŠ¡
â”œâ”€â”€ receipts.module.ts          # ç­¾æ”¶å•æ¨¡å—
â”œâ”€â”€ entities/
â”‚   â””â”€â”€ receipt.entity.ts       # ç­¾æ”¶å•å®ä½“
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-receipt.dto.ts   # åˆ›å»ºç­¾æ”¶å•DTO
â”‚   â”œâ”€â”€ update-receipt.dto.ts   # æ›´æ–°ç­¾æ”¶å•DTO
â”‚   â””â”€â”€ upload-receipt.dto.ts   # ä¸Šä¼ ç­¾æ”¶å•DTO
â””â”€â”€ services/
    â””â”€â”€ image-compression.service.ts # å›¾ç‰‡å‹ç¼©æœåŠ¡
```

### å‰ç«¯ç»“æ„
```
admin-frontend/src/app/receipts/
â”œâ”€â”€ page.tsx                    # ç­¾æ”¶å•ç®¡ç†é¡µé¢
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ReceiptTable.tsx        # ç­¾æ”¶å•è¡¨æ ¼ç»„ä»¶
â”‚   â”œâ”€â”€ ReceiptDetail.tsx       # ç­¾æ”¶å•è¯¦æƒ…ç»„ä»¶
â”‚   â”œâ”€â”€ ImagePreview.tsx        # å›¾ç‰‡é¢„è§ˆç»„ä»¶
â”‚   â””â”€â”€ SearchForm.tsx          # æœç´¢è¡¨å•ç»„ä»¶
â””â”€â”€ hooks/
    â””â”€â”€ useReceipts.tsx         # ç­¾æ”¶å•æ•°æ®Hook
```

## ğŸ—„ï¸ æ•°æ®å®ä½“è®¾è®¡

### ç­¾æ”¶å•å®ä½“ (Receipt)
```typescript
@Entity('t_receipts')
export class Receipt {
  @PrimaryGeneratedColumn({ comment: 'ç­¾æ”¶å•ID' })
  id: number;

  @Column({ name: 'customer_number', length: 50, comment: 'å®¢æˆ·ç¼–å·' })
  customerNumber: string;

  @Column({ name: 'customer_name', length: 100, comment: 'å®¢æˆ·åç§°' })
  customerName: string;

  @Column({ name: 'operator_name', length: 50, comment: 'æ“ä½œå‘˜å§“å' })
  operatorName: string;

  @Column({ name: 'operator_phone', length: 20, nullable: true, comment: 'æ“ä½œå‘˜æ‰‹æœºå·' })
  operatorPhone?: string;

  @Column({ name: 'image_path', length: 500, comment: 'å›¾ç‰‡è·¯å¾„' })
  imagePath: string;

  @Column({ name: 'image_url', length: 500, comment: 'å›¾ç‰‡è®¿é—®URL' })
  imageUrl: string;

  @Column({ name: 'original_filename', length: 255, comment: 'åŸå§‹æ–‡ä»¶å' })
  originalFilename: string;

  @Column({ name: 'file_size', type: 'int', comment: 'æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰' })
  fileSize: number;

  @Column({ name: 'compressed_size', type: 'int', nullable: true, comment: 'å‹ç¼©åå¤§å°ï¼ˆå­—èŠ‚ï¼‰' })
  compressedSize?: number;

  @Column({ name: 'upload_longitude', type: 'decimal', precision: 10, scale: 7, nullable: true })
  uploadLongitude?: number;

  @Column({ name: 'upload_latitude', type: 'decimal', precision: 10, scale: 7, nullable: true })
  uploadLatitude?: number;

  @Column({ name: 'upload_address', length: 500, nullable: true, comment: 'ä¸Šä¼ åœ°å€' })
  uploadAddress?: string;

  @Column({ name: 'upload_time', type: 'datetime', comment: 'ä¸Šä¼ æ—¶é—´' })
  uploadTime: Date;

  @Column({ name: 'remarks', type: 'text', nullable: true, comment: 'å¤‡æ³¨ä¿¡æ¯' })
  remarks?: string;

  @Column({ name: 'wx_user_id', type: 'int', nullable: true, comment: 'å°ç¨‹åºç”¨æˆ·ID' })
  wxUserId?: number;

  @Column({ name: 'is_deleted', type: 'tinyint', width: 1, default: 0 })
  isDeleted: number;

  @CreateDateColumn({ name: 'created_at', comment: 'åˆ›å»ºæ—¶é—´' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at', comment: 'æ›´æ–°æ—¶é—´' })
  updatedAt: Date;
}
```

## ğŸ–¼ï¸ å›¾ç‰‡å‹ç¼©æœåŠ¡

### å›¾ç‰‡å‹ç¼©æœåŠ¡ (ImageCompressionService)
```typescript
@Injectable()
export class ImageCompressionService {
  private readonly logger = new CustomLogger('ImageCompressionService');

  /**
   * å‹ç¼©å›¾ç‰‡
   */
  async compressImage(inputPath: string, outputPath: string, options: CompressionOptions = {}): Promise<CompressionResult> {
    const {
      quality = 80,
      maxWidth = 1920,
      maxHeight = 1080,
      format = 'jpeg'
    } = options;

    try {
      // è·å–åŸå§‹æ–‡ä»¶ä¿¡æ¯
      const originalStats = await fs.stat(inputPath);
      const originalSize = originalStats.size;

      this.logger.log(`å¼€å§‹å‹ç¼©å›¾ç‰‡ - åŸå§‹å¤§å°: ${this.formatFileSize(originalSize)}, è¾“å…¥è·¯å¾„: ${inputPath}`);

      // ä½¿ç”¨Sharpè¿›è¡Œå›¾ç‰‡å‹ç¼©
      const sharpInstance = sharp(inputPath);
      
      // è·å–å›¾ç‰‡å…ƒæ•°æ®
      const metadata = await sharpInstance.metadata();
      this.logger.log(`å›¾ç‰‡ä¿¡æ¯ - å®½åº¦: ${metadata.width}, é«˜åº¦: ${metadata.height}, æ ¼å¼: ${metadata.format}`);

      // è°ƒæ•´å›¾ç‰‡å°ºå¯¸å’Œè´¨é‡
      let processedImage = sharpInstance;

      // å¦‚æœå›¾ç‰‡å°ºå¯¸è¶…è¿‡é™åˆ¶ï¼Œè¿›è¡Œç¼©æ”¾
      if (metadata.width > maxWidth || metadata.height > maxHeight) {
        processedImage = processedImage.resize(maxWidth, maxHeight, {
          fit: 'inside',
          withoutEnlargement: true
        });
        this.logger.log(`å›¾ç‰‡å°ºå¯¸è°ƒæ•´ - æœ€å¤§å®½åº¦: ${maxWidth}, æœ€å¤§é«˜åº¦: ${maxHeight}`);
      }

      // æ ¹æ®æ ¼å¼è¿›è¡Œå‹ç¼©
      switch (format.toLowerCase()) {
        case 'jpeg':
        case 'jpg':
          processedImage = processedImage.jpeg({ quality, progressive: true });
          break;
        case 'png':
          processedImage = processedImage.png({ quality, progressive: true });
          break;
        case 'webp':
          processedImage = processedImage.webp({ quality });
          break;
        default:
          processedImage = processedImage.jpeg({ quality, progressive: true });
      }

      // ä¿å­˜å‹ç¼©åçš„å›¾ç‰‡
      await processedImage.toFile(outputPath);

      // è·å–å‹ç¼©åæ–‡ä»¶ä¿¡æ¯
      const compressedStats = await fs.stat(outputPath);
      const compressedSize = compressedStats.size;
      const compressionRatio = ((originalSize - compressedSize) / originalSize * 100).toFixed(2);

      this.logger.log(`å›¾ç‰‡å‹ç¼©å®Œæˆ - å‹ç¼©åå¤§å°: ${this.formatFileSize(compressedSize)}, å‹ç¼©ç‡: ${compressionRatio}%`);

      return {
        originalSize,
        compressedSize,
        compressionRatio: parseFloat(compressionRatio),
        outputPath,
        success: true
      };
    } catch (error) {
      this.logger.error(`å›¾ç‰‡å‹ç¼©å¤±è´¥: ${error.message}`, error.stack);
      return {
        originalSize: 0,
        compressedSize: 0,
        compressionRatio: 0,
        outputPath: '',
        success: false,
        error: error.message
      };
    }
  }

  /**
   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°æ˜¾ç¤º
   */
  private formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * éªŒè¯å›¾ç‰‡æ ¼å¼
   */
  isValidImageFormat(filename: string): boolean {
    const validExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
    const extension = path.extname(filename).toLowerCase();
    return validExtensions.includes(extension);
  }

  /**
   * è·å–å›¾ç‰‡MIMEç±»å‹
   */
  getImageMimeType(filename: string): string {
    const extension = path.extname(filename).toLowerCase();
    const mimeTypes = {
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.webp': 'image/webp'
    };
    return mimeTypes[extension] || 'image/jpeg';
  }
}

// å‹ç¼©é€‰é¡¹æ¥å£
interface CompressionOptions {
  quality?: number;      // å‹ç¼©è´¨é‡ (1-100)
  maxWidth?: number;     // æœ€å¤§å®½åº¦
  maxHeight?: number;    // æœ€å¤§é«˜åº¦
  format?: string;       // è¾“å‡ºæ ¼å¼
}

// å‹ç¼©ç»“æœæ¥å£
interface CompressionResult {
  originalSize: number;
  compressedSize: number;
  compressionRatio: number;
  outputPath: string;
  success: boolean;
  error?: string;
}
```

## ğŸ” ç­¾æ”¶å•æœåŠ¡å®ç°

### ç­¾æ”¶å•æœåŠ¡ (ReceiptsService)
```typescript
@Injectable()
export class ReceiptsService {
  private readonly logger = new CustomLogger('ReceiptsService');

  constructor(
    @InjectRepository(Receipt)
    private receiptRepository: Repository<Receipt>,
    private imageCompressionService: ImageCompressionService,
  ) {}

  /**
   * åˆ†é¡µæŸ¥è¯¢ç­¾æ”¶å•åˆ—è¡¨
   */
  async findAll(page: number = 1, limit: number = 10, user?: any): Promise<PaginatedResponse<Receipt>> {
    const skip = (page - 1) * limit;

    const [receipts, total] = await this.receiptRepository.findAndCount({
      where: { isDeleted: 0 },
      skip,
      take: limit,
      order: { uploadTime: 'DESC' },
    });

    this.logger.log(`æŸ¥è¯¢ç­¾æ”¶å•åˆ—è¡¨ - é¡µç : ${page}, æ¯é¡µ: ${limit}, æ€»æ•°: ${total}, ç”¨æˆ·: ${user?.id || 'æœªçŸ¥'}`);

    return {
      data: receipts,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  /**
   * æœç´¢ç­¾æ”¶å•
   */
  async search(searchParams: any, user?: any): Promise<PaginatedResponse<Receipt>> {
    const { customerNumber, customerName, operatorName, startDate, endDate, page = 1, limit = 10 } = searchParams;
    const skip = (page - 1) * limit;

    const queryBuilder = this.receiptRepository.createQueryBuilder('receipt')
      .where('receipt.isDeleted = :isDeleted', { isDeleted: 0 });

    // å®¢æˆ·ç¼–å·æœç´¢
    if (customerNumber) {
      queryBuilder.andWhere('receipt.customerNumber LIKE :customerNumber', { customerNumber: `%${customerNumber}%` });
    }

    // å®¢æˆ·åç§°æœç´¢
    if (customerName) {
      queryBuilder.andWhere('receipt.customerName LIKE :customerName', { customerName: `%${customerName}%` });
    }

    // æ“ä½œå‘˜æœç´¢
    if (operatorName) {
      queryBuilder.andWhere('receipt.operatorName LIKE :operatorName', { operatorName: `%${operatorName}%` });
    }

    // æ—¶é—´èŒƒå›´æœç´¢
    if (startDate) {
      queryBuilder.andWhere('receipt.uploadTime >= :startDate', { startDate });
    }
    if (endDate) {
      queryBuilder.andWhere('receipt.uploadTime <= :endDate', { endDate });
    }

    // åˆ†é¡µå’Œæ’åº
    queryBuilder
      .skip(skip)
      .take(limit)
      .orderBy('receipt.uploadTime', 'DESC');

    const [receipts, total] = await queryBuilder.getManyAndCount();

    this.logger.log(`æœç´¢ç­¾æ”¶å• - å®¢æˆ·ç¼–å·: ${customerNumber}, å®¢æˆ·åç§°: ${customerName}, ç»“æœæ•°: ${receipts.length}, ç”¨æˆ·: ${user?.id || 'æœªçŸ¥'}`);

    return {
      data: receipts,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  /**
   * ä¸Šä¼ ç­¾æ”¶å•
   */
  async uploadReceipt(
    file: Express.Multer.File,
    uploadReceiptDto: UploadReceiptDto,
    user?: any
  ): Promise<Receipt> {
    const {
      customerNumber,
      customerName,
      operatorName,
      operatorPhone,
      uploadLongitude,
      uploadLatitude,
      uploadAddress,
      remarks
    } = uploadReceiptDto;

    try {
      // éªŒè¯æ–‡ä»¶æ ¼å¼
      if (!this.imageCompressionService.isValidImageFormat(file.originalname)) {
        throw new BadRequestException('ä¸æ”¯æŒçš„å›¾ç‰‡æ ¼å¼ï¼Œè¯·ä¸Šä¼  JPGã€PNGã€GIF æˆ– WebP æ ¼å¼çš„å›¾ç‰‡');
      }

      // ç”Ÿæˆæ–‡ä»¶è·¯å¾„
      const uploadDir = UploadConfig.getUploadPath('receipts');
      const filename = this.generateFilename(file.originalname);
      const originalPath = path.join(uploadDir, filename);
      const compressedFilename = `compressed_${filename}`;
      const compressedPath = path.join(uploadDir, compressedFilename);

      // ç¡®ä¿ä¸Šä¼ ç›®å½•å­˜åœ¨
      await fs.ensureDir(uploadDir);

      // ä¿å­˜åŸå§‹æ–‡ä»¶
      await fs.writeFile(originalPath, file.buffer);
      this.logger.log(`ä¿å­˜åŸå§‹æ–‡ä»¶ - è·¯å¾„: ${originalPath}, å¤§å°: ${file.size} bytes`);

      // å‹ç¼©å›¾ç‰‡
      const compressionResult = await this.imageCompressionService.compressImage(
        originalPath,
        compressedPath,
        {
          quality: 80,
          maxWidth: 1920,
          maxHeight: 1080,
          format: 'jpeg'
        }
      );

      let finalPath = originalPath;
      let finalSize = file.size;
      let compressedSize = null;

      if (compressionResult.success && compressionResult.compressedSize < file.size) {
        // å¦‚æœå‹ç¼©æˆåŠŸä¸”æ–‡ä»¶æ›´å°ï¼Œä½¿ç”¨å‹ç¼©åçš„æ–‡ä»¶
        finalPath = compressedPath;
        finalSize = compressionResult.compressedSize;
        compressedSize = compressionResult.compressedSize;
        
        // åˆ é™¤åŸå§‹æ–‡ä»¶
        await fs.remove(originalPath);
        this.logger.log(`ä½¿ç”¨å‹ç¼©æ–‡ä»¶ - å‹ç¼©ç‡: ${compressionResult.compressionRatio}%`);
      } else {
        // å¦åˆ™ä½¿ç”¨åŸå§‹æ–‡ä»¶ï¼Œåˆ é™¤å‹ç¼©æ–‡ä»¶
        if (await fs.pathExists(compressedPath)) {
          await fs.remove(compressedPath);
        }
        this.logger.log('ä½¿ç”¨åŸå§‹æ–‡ä»¶ - å‹ç¼©æ•ˆæœä¸ä½³æˆ–å¤±è´¥');
      }

      // ç”Ÿæˆè®¿é—®URL
      const imageUrl = `/receipts/uploads/${path.basename(finalPath)}`;

      // åˆ›å»ºç­¾æ”¶å•è®°å½•
      const receipt = this.receiptRepository.create({
        customerNumber,
        customerName,
        operatorName,
        operatorPhone,
        imagePath: finalPath,
        imageUrl,
        originalFilename: file.originalname,
        fileSize: file.size,
        compressedSize,
        uploadLongitude: uploadLongitude ? parseFloat(uploadLongitude.toString()) : null,
        uploadLatitude: uploadLatitude ? parseFloat(uploadLatitude.toString()) : null,
        uploadAddress,
        uploadTime: new Date(),
        remarks,
        wxUserId: user?.id,
      });

      const savedReceipt = await this.receiptRepository.save(receipt);

      this.logger.log(`ç­¾æ”¶å•ä¸Šä¼ æˆåŠŸ - ID: ${savedReceipt.id}, å®¢æˆ·: ${customerName}, æ“ä½œå‘˜: ${operatorName}, æ–‡ä»¶å¤§å°: ${finalSize} bytes`);

      return savedReceipt;
    } catch (error) {
      this.logger.error(`ç­¾æ”¶å•ä¸Šä¼ å¤±è´¥: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * åˆ é™¤ç­¾æ”¶å•
   */
  async remove(id: number, user?: any): Promise<void> {
    const receipt = await this.findOne(id);

    // è½¯åˆ é™¤
    await this.receiptRepository.update(id, { isDeleted: 1 });

    // åˆ é™¤æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
    try {
      if (await fs.pathExists(receipt.imagePath)) {
        await fs.remove(receipt.imagePath);
        this.logger.log(`åˆ é™¤ç­¾æ”¶å•æ–‡ä»¶ - è·¯å¾„: ${receipt.imagePath}`);
      }
    } catch (error) {
      this.logger.warn(`åˆ é™¤æ–‡ä»¶å¤±è´¥: ${error.message}`);
    }

    this.logger.log(`åˆ é™¤ç­¾æ”¶å•æˆåŠŸ - ID: ${id}, å®¢æˆ·: ${receipt.customerName}, æ“ä½œäºº: ${user?.username || 'ç³»ç»Ÿ'}`);
  }

  /**
   * æ‰¹é‡åˆ é™¤ç­¾æ”¶å•
   */
  async batchRemove(ids: number[], user?: any): Promise<void> {
    const receipts = await this.receiptRepository.findByIds(ids);

    // æ‰¹é‡è½¯åˆ é™¤
    await this.receiptRepository.update(
      { id: In(ids) },
      { isDeleted: 1 }
    );

    // åˆ é™¤æ–‡ä»¶
    for (const receipt of receipts) {
      try {
        if (await fs.pathExists(receipt.imagePath)) {
          await fs.remove(receipt.imagePath);
        }
      } catch (error) {
        this.logger.warn(`åˆ é™¤æ–‡ä»¶å¤±è´¥: ${receipt.imagePath} - ${error.message}`);
      }
    }

    this.logger.log(`æ‰¹é‡åˆ é™¤ç­¾æ”¶å•æˆåŠŸ - æ•°é‡: ${ids.length}, æ“ä½œäºº: ${user?.username || 'ç³»ç»Ÿ'}`);
  }

  /**
   * ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
   */
  private generateFilename(originalname: string): string {
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(2, 15);
    const extension = path.extname(originalname);
    return `${timestamp}_${randomString}${extension}`;
  }

  /**
   * æ ¹æ®IDæŸ¥æ‰¾ç­¾æ”¶å•
   */
  async findOne(id: number): Promise<Receipt> {
    const receipt = await this.receiptRepository.findOne({
      where: { id, isDeleted: 0 },
    });

    if (!receipt) {
      throw new NotFoundException(`ç­¾æ”¶å•ä¸å­˜åœ¨ (ID: ${id})`);
    }

    return receipt;
  }
}
```

## ğŸ¯ æ§åˆ¶å™¨å®ç°

### ç­¾æ”¶å•æ§åˆ¶å™¨ (ReceiptsController)
```typescript
@ApiTags('ç­¾æ”¶å•ç®¡ç†')
@Controller('receipts')
@UseGuards(JwtAuthGuard)
export class ReceiptsController {
  private readonly logger = new CustomLogger('ReceiptsController');

  constructor(private readonly receiptsService: ReceiptsService) {}

  @Get()
  @ApiOperation({ summary: 'è·å–ç­¾æ”¶å•åˆ—è¡¨' })
  async findAll(
    @Query('page') page: number = 1,
    @Query('limit') limit: number = 10,
    @Req() req,
  ) {
    return this.receiptsService.findAll(page, limit, req.user);
  }

  @Get('search')
  @ApiOperation({ summary: 'æœç´¢ç­¾æ”¶å•' })
  async search(@Query() searchParams: any, @Req() req) {
    return this.receiptsService.search(searchParams, req.user);
  }

  @Get(':id')
  @ApiOperation({ summary: 'è·å–ç­¾æ”¶å•è¯¦æƒ…' })
  async findOne(@Param('id') id: string) {
    return this.receiptsService.findOne(+id);
  }

  @Post('upload')
  @ApiOperation({ summary: 'ä¸Šä¼ ç­¾æ”¶å•' })
  @UseInterceptors(FileInterceptor('file', {
    limits: {
      fileSize: 10 * 1024 * 1024, // 10MB
    },
    fileFilter: (req, file, callback) => {
      if (!file.mimetype.startsWith('image/')) {
        return callback(new BadRequestException('åªèƒ½ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶'), false);
      }
      callback(null, true);
    },
  }))
  async uploadReceipt(
    @UploadedFile() file: Express.Multer.File,
    @Body() uploadReceiptDto: UploadReceiptDto,
    @Req() req,
  ) {
    if (!file) {
      throw new BadRequestException('è¯·é€‰æ‹©è¦ä¸Šä¼ çš„å›¾ç‰‡æ–‡ä»¶');
    }

    return this.receiptsService.uploadReceipt(file, uploadReceiptDto, req.user);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'åˆ é™¤ç­¾æ”¶å•' })
  async remove(@Param('id') id: string, @Req() req) {
    return this.receiptsService.remove(+id, req.user);
  }

  @Delete('batch')
  @ApiOperation({ summary: 'æ‰¹é‡åˆ é™¤ç­¾æ”¶å•' })
  async batchRemove(@Body() { ids }: { ids: number[] }, @Req() req) {
    return this.receiptsService.batchRemove(ids, req.user);
  }
}
```

## ğŸ¨ å‰ç«¯å®ç°

### ç­¾æ”¶å•ç®¡ç†é¡µé¢
```typescript
export default function ReceiptsPage() {
  const [receipts, setReceipts] = useState<Receipt[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedReceipt, setSelectedReceipt] = useState<Receipt | null>(null);
  const [showImagePreview, setShowImagePreview] = useState(false);

  const fetchReceipts = async (page = 1, limit = 10, searchParams = {}) => {
    setLoading(true);
    try {
      const response = await api.get('/receipts', {
        params: { page, limit, ...searchParams },
      });
      
      setReceipts(response.data.data);
    } catch (error) {
      console.error('è·å–ç­¾æ”¶å•åˆ—è¡¨å¤±è´¥:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleImagePreview = (receipt: Receipt) => {
    setSelectedReceipt(receipt);
    setShowImagePreview(true);
  };

  const handleDelete = async (id: number) => {
    try {
      await api.delete(`/receipts/${id}`);
      message.success('åˆ é™¤æˆåŠŸ');
      fetchReceipts();
    } catch (error) {
      message.error('åˆ é™¤å¤±è´¥');
    }
  };

  return (
    <div className="receipts-management">
      <div className="header">
        <h1>ç­¾æ”¶å•ç®¡ç†</h1>
      </div>

      <SearchForm onSearch={fetchReceipts} />
      
      <ReceiptTable
        receipts={receipts}
        loading={loading}
        onImagePreview={handleImagePreview}
        onDelete={handleDelete}
      />

      <ImagePreview
        visible={showImagePreview}
        receipt={selectedReceipt}
        onClose={() => setShowImagePreview(false)}
      />
    </div>
  );
}
```

---

**ç›¸å…³æ–‡æ¡£**:
- [æ–‡ä»¶ä¸Šä¼ é…ç½®](../05-å¼€å‘æŒ‡å—/æ–‡ä»¶ä¸Šä¼ é…ç½®.md)
- [å›¾ç‰‡å¤„ç†æœåŠ¡](./å›¾ç‰‡å¤„ç†æ¨¡å—å®ç°.md)
- [å°ç¨‹åºä¸Šä¼ åŠŸèƒ½](./å°ç¨‹åºä¸Šä¼ æ¨¡å—å®ç°.md)
