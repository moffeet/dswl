# ğŸ›¡ï¸ æƒé™ç®¡ç†æ¨¡å—å®ç°è¯¦è§£

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

æƒé™ç®¡ç†æ¨¡å—åŸºäºRBACï¼ˆåŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼‰æ¨¡å‹ï¼Œå®ç°äº†ç”¨æˆ·-è§’è‰²-æƒé™çš„ä¸‰å±‚æƒé™æ§åˆ¶ä½“ç³»ã€‚æ”¯æŒç»†ç²’åº¦çš„é¡µé¢è®¿é—®æ§åˆ¶å’Œæ“ä½œæƒé™æ§åˆ¶ã€‚

## ğŸ—ï¸ æ¨¡å—æ¶æ„

### ç›®å½•ç»“æ„
```
backend-node/src/
â”œâ”€â”€ users/                     # ç”¨æˆ·ç®¡ç†
â”‚   â”œâ”€â”€ users.controller.ts
â”‚   â”œâ”€â”€ users.service.ts
â”‚   â””â”€â”€ entities/user.entity.ts
â”œâ”€â”€ roles/                     # è§’è‰²ç®¡ç†
â”‚   â”œâ”€â”€ roles.controller.ts
â”‚   â”œâ”€â”€ roles.service.ts
â”‚   â””â”€â”€ entities/role.entity.ts
â”œâ”€â”€ permissions/               # æƒé™ç®¡ç†
â”‚   â”œâ”€â”€ permissions.controller.ts
â”‚   â”œâ”€â”€ permissions.service.ts
â”‚   â””â”€â”€ entities/permission.entity.ts
â””â”€â”€ auth/
    â”œâ”€â”€ permission-check.service.ts  # æƒé™æ£€æŸ¥æœåŠ¡
    â””â”€â”€ casl-ability.factory.ts     # CASLæƒé™å·¥å‚
```

### æ•°æ®æ¨¡å‹å…³ç³»
```
User (ç”¨æˆ·) â†â†’ UserRole (ç”¨æˆ·è§’è‰²) â†â†’ Role (è§’è‰²)
                                        â†“
                                   RolePermission (è§’è‰²æƒé™)
                                        â†“
                                 Permission (æƒé™)
```

## ğŸ—„ï¸ æ•°æ®å®ä½“è®¾è®¡

### 1. ç”¨æˆ·å®ä½“ (User)
```typescript
@Entity('t_users')
export class User {
  @PrimaryGeneratedColumn({ comment: 'ç”¨æˆ·ID' })
  id: number;

  @Column({ length: 50, unique: true, comment: 'ç”¨æˆ·å' })
  username: string;

  @Column({ length: 255, comment: 'å¯†ç ï¼ˆåŠ å¯†åï¼‰' })
  password: string;

  @Column({ length: 100, nullable: false, comment: 'æ˜µç§°' })
  nickname: string;

  @Column({ name: 'is_first_login', type: 'tinyint', width: 1, default: 1 })
  isFirstLogin: number;

  @Column({ name: 'last_login_time', type: 'datetime', nullable: true })
  lastLoginTime?: Date;

  @Column({ name: 'is_deleted', type: 'tinyint', width: 1, default: 0 })
  isDeleted: number;

  // å¤šå¯¹å¤šå…³ç³»ï¼šç”¨æˆ·-è§’è‰²
  @ManyToMany(() => Role)
  @JoinTable({
    name: 't_user_roles',
    joinColumn: { name: 'user_id', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'role_id', referencedColumnName: 'id' }
  })
  roles: Role[];
}
```

### 2. è§’è‰²å®ä½“ (Role)
```typescript
@Entity('t_roles')
export class Role {
  @PrimaryGeneratedColumn({ comment: 'è§’è‰²ID' })
  id: number;

  @Column({ name: 'role_name', length: 50, comment: 'è§’è‰²åç§°' })
  roleName: string;

  @Column({ name: 'role_code', length: 50, unique: true, comment: 'è§’è‰²ä»£ç ' })
  roleCode: string;

  @Column({ length: 200, nullable: true, comment: 'è§’è‰²æè¿°' })
  description?: string;

  @Column({ name: 'is_deleted', type: 'tinyint', width: 1, default: 0 })
  isDeleted: number;

  // å¤šå¯¹å¤šå…³ç³»ï¼šè§’è‰²-æƒé™
  @ManyToMany(() => Permission)
  @JoinTable({
    name: 't_role_permissions',
    joinColumn: { name: 'role_id', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'permission_id', referencedColumnName: 'id' }
  })
  permissions: Permission[];
}
```

### 3. æƒé™å®ä½“ (Permission)
```typescript
@Entity('t_permissions')
export class Permission {
  @PrimaryGeneratedColumn({ comment: 'æƒé™ID' })
  id: number;

  @Column({ name: 'permission_name', length: 100, comment: 'æƒé™åç§°' })
  permissionName: string;

  @Column({ name: 'permission_code', length: 100, unique: true, comment: 'æƒé™ä»£ç ' })
  permissionCode: string;

  @Column({ name: 'permission_type', type: 'enum', enum: PermissionType, comment: 'æƒé™ç±»å‹' })
  permissionType: PermissionType;

  @Column({ length: 200, nullable: true, comment: 'æƒé™æè¿°' })
  description?: string;

  @Column({ type: 'enum', enum: PermissionStatus, default: PermissionStatus.NORMAL })
  status: PermissionStatus;
}

export enum PermissionType {
  MENU = 'menu',     // èœå•æƒé™
  ACTION = 'action'  // æ“ä½œæƒé™
}

export enum PermissionStatus {
  NORMAL = 'normal',     // æ­£å¸¸
  DISABLED = 'disabled'  // ç¦ç”¨
}
```

## ğŸ” æƒé™æ£€æŸ¥æœåŠ¡å®ç°

### æ ¸å¿ƒæƒé™æ£€æŸ¥é€»è¾‘
```typescript
@Injectable()
export class PermissionCheckService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
    @InjectRepository(Role)
    private roleRepository: Repository<Role>,
    @InjectRepository(Permission)
    private permissionRepository: Repository<Permission>,
  ) {}

  /**
   * è·å–ç”¨æˆ·æƒé™ä¿¡æ¯
   */
  async getUserPermissionInfo(userId: number): Promise<UserPermissionInfo> {
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const user = await this.userRepository.findOne({
      where: { id: userId, isDeleted: 0 }
    });

    if (!user) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    // æ‰‹åŠ¨æŸ¥è¯¢ç”¨æˆ·çš„è§’è‰²ä¿¡æ¯
    const roles = await this.roleRepository
      .createQueryBuilder('role')
      .innerJoin('t_user_roles', 'ur', 'ur.role_id = role.id')
      .where('ur.user_id = :userId', { userId })
      .andWhere('role.is_deleted = 0')
      .getMany();

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰è§’è‰²
    const hasRole = roles && roles.length > 0;

    // æ£€æŸ¥æ˜¯å¦ä¸ºè¶…çº§ç®¡ç†å‘˜
    const isAdmin = roles.some(role => role.roleCode === 'admin');

    // è·å–ç”¨æˆ·çš„æ‰€æœ‰æƒé™
    let permissions: string[] = [];
    if (hasRole) {
      if (isAdmin) {
        // è¶…çº§ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™
        const { generateAllPermissions } = await import('../common/constants/permissions');
        const allPermissions = generateAllPermissions();
        permissions = allPermissions.map(p => p.code);
      } else {
        // è·å–æ‰€æœ‰è§’è‰²çš„æƒé™
        const roleIds = roles.map(role => role.id);
        if (roleIds.length > 0) {
          const rolePermissions = await this.permissionRepository
            .createQueryBuilder('permission')
            .innerJoin('t_role_permissions', 'rp', 'rp.permission_id = permission.id')
            .where('rp.role_id IN (:...roleIds)', { roleIds })
            .andWhere('permission.status = :status', { status: 'normal' })
            .getMany();

          permissions = rolePermissions.map(p => p.permissionCode);
        }
      }
    }

    return {
      hasRole,
      roles,
      permissions,
      canAccessPage: (path: string) => this.canAccessPage(path, permissions, hasRole, isAdmin),
      canPerformAction: (actionCode: string) => isAdmin || permissions.includes(actionCode)
    };
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥è®¿é—®æŒ‡å®šé¡µé¢
   */
  private canAccessPage(path: string, permissions: string[], hasRole: boolean, isAdmin: boolean = false): boolean {
    // è¶…çº§ç®¡ç†å‘˜å¯ä»¥è®¿é—®æ‰€æœ‰é¡µé¢
    if (isAdmin) {
      return true;
    }

    // å¦‚æœæ²¡æœ‰è§’è‰²ï¼Œåªèƒ½è®¿é—®homeé¡µé¢
    if (!hasRole) {
      return path === '/' || path === '/home' || path === '';
    }

    // homeé¡µé¢æ‰€æœ‰ç”¨æˆ·éƒ½å¯ä»¥è®¿é—®
    if (path === '/' || path === '/home' || path === '') {
      return true;
    }

    // é¡µé¢è·¯å¾„ä¸æƒé™ä»£ç çš„æ˜ å°„
    const pagePermissionMap: { [key: string]: string } = {
      '/users': 'menu.users',
      '/roles': 'menu.roles',
      '/customer': 'menu.customer',
      '/receipts': 'menu.receipts',
      '/wx-user': 'menu.wxuser',
      '/map': 'menu.map',
      '/permissions': 'menu.permissions'
    };

    // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”é¡µé¢çš„æƒé™
    const requiredPermission = pagePermissionMap[path];
    if (requiredPermission) {
      return permissions.includes(requiredPermission);
    }

    // å¯¹äºæœªå®šä¹‰çš„é¡µé¢ï¼Œæœ‰è§’è‰²çš„ç”¨æˆ·å¯ä»¥è®¿é—®
    return hasRole;
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ä¸ºè¶…çº§ç®¡ç†å‘˜
   */
  async isAdmin(userId: number): Promise<boolean> {
    const roles = await this.roleRepository
      .createQueryBuilder('role')
      .innerJoin('t_user_roles', 'ur', 'ur.role_id = role.id')
      .where('ur.user_id = :userId', { userId })
      .andWhere('role.is_deleted = 0')
      .getMany();

    if (!roles || roles.length === 0) {
      return false;
    }

    return roles.some(role => role.roleCode === 'admin');
  }
}
```

## ğŸ¯ CASLæƒé™å·¥å‚

### åŠ¨æ€æƒé™èƒ½åŠ›å®šä¹‰
```typescript
@Injectable()
export class CaslAbilityFactory {
  createForUser(user: any) {
    const { can, cannot, build } = new AbilityBuilder<
      Ability<[Action, Subjects]>
    >(Ability as AbilityClass<AppAbility>);

    // æ ¹æ®ç”¨æˆ·è§’è‰²å®šä¹‰æƒé™
    if (user.roles?.some(role => role.roleCode === 'admin')) {
      // è¶…çº§ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™
      can(Action.Manage, 'all');
    } else {
      // æ™®é€šç”¨æˆ·æƒé™
      can(Action.Read, 'User', { id: user.id });
      can(Action.Update, 'User', { id: user.id });
      
      // æ ¹æ®ç”¨æˆ·çš„å…·ä½“æƒé™è®¾ç½®
      user.permissions?.forEach(permission => {
        switch (permission.permissionCode) {
          case 'user.read':
            can(Action.Read, 'User');
            break;
          case 'user.create':
            can(Action.Create, 'User');
            break;
          case 'user.update':
            can(Action.Update, 'User');
            break;
          case 'user.delete':
            can(Action.Delete, 'User');
            break;
          // æ›´å¤šæƒé™æ˜ å°„...
        }
      });
    }

    return build({
      detectSubjectType: (item) =>
        item.constructor as ExtractSubjectType<Subjects>,
    });
  }
}

// æƒé™åŠ¨ä½œæšä¸¾
export enum Action {
  Manage = 'manage',
  Create = 'create',
  Read = 'read',
  Update = 'update',
  Delete = 'delete',
}

// æƒé™ä¸»ä½“ç±»å‹
type Subjects = InferSubjects<typeof User | typeof Role | typeof Permission> | 'all';
export type AppAbility = Ability<[Action, Subjects]>;
```

## ğŸ”§ æƒé™è£…é¥°å™¨

### æƒé™æ£€æŸ¥è£…é¥°å™¨
```typescript
// æƒé™æ£€æŸ¥è£…é¥°å™¨
export const CheckPermissions = (...permissions: string[]) =>
  SetMetadata('permissions', permissions);

// æƒé™å®ˆå«
@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private caslAbilityFactory: CaslAbilityFactory,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredPermissions = this.reflector.get<string[]>(
      'permissions',
      context.getHandler(),
    );

    if (!requiredPermissions) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    const ability = this.caslAbilityFactory.createForUser(user);

    return requiredPermissions.every((permission) =>
      ability.can(Action.Manage, permission),
    );
  }
}
```

## ğŸ¨ å‰ç«¯æƒé™æ§åˆ¶

### Reactæƒé™ä¸Šä¸‹æ–‡
```typescript
// æƒé™ä¸Šä¸‹æ–‡
export const PermissionContext = createContext<{
  permissionInfo: UserPermissionInfo | null;
  hasRole: boolean;
  canAccessPage: (path: string) => boolean;
  canPerformAction: (actionCode: string) => boolean;
  isLoading: boolean;
}>({
  permissionInfo: null,
  hasRole: false,
  canAccessPage: () => false,
  canPerformAction: () => false,
  isLoading: true,
});

// æƒé™æä¾›è€…ç»„ä»¶
export function PermissionProvider({ children }: { children: React.ReactNode }) {
  const [permissionInfo, setPermissionInfo] = useState<UserPermissionInfo | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchPermissions = async () => {
      try {
        const response = await api.get('/auth/permissions');
        setPermissionInfo(response.data);
      } catch (error) {
        console.error('è·å–æƒé™ä¿¡æ¯å¤±è´¥:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchPermissions();
  }, []);

  const hasRole = permissionInfo?.hasRole || false;
  
  const canAccessPage = useCallback((path: string): boolean => {
    if (!permissionInfo) return false;
    return permissionInfo.canAccessPage(path);
  }, [permissionInfo]);

  const canPerformAction = useCallback((actionCode: string): boolean => {
    if (!permissionInfo) return false;
    return permissionInfo.canPerformAction(actionCode);
  }, [permissionInfo]);

  return (
    <PermissionContext.Provider value={{
      permissionInfo,
      hasRole,
      canAccessPage,
      canPerformAction,
      isLoading,
    }}>
      {children}
    </PermissionContext.Provider>
  );
}
```

### é¡µé¢æƒé™å®ˆå«ç»„ä»¶
```typescript
export function PagePermissionGuard({ children }: { children: React.ReactNode }) {
  const { isLoading, hasRole, canAccessPage } = useContext(PermissionContext);
  const pathname = usePathname();
  const router = useRouter();

  useEffect(() => {
    // å¦‚æœæ­£åœ¨åŠ è½½æƒé™ä¿¡æ¯ï¼Œä¸åšä»»ä½•å¤„ç†
    if (isLoading) {
      return;
    }

    // å¦‚æœæ²¡æœ‰è§’è‰²ä¸”ä¸æ˜¯é¦–é¡µï¼Œè·³è½¬åˆ°é¦–é¡µ
    if (!hasRole && pathname !== '/' && pathname !== '/home') {
      router.push('/');
      return;
    }

    // å¦‚æœæœ‰è§’è‰²ä½†æ²¡æœ‰æƒé™è®¿é—®å½“å‰é¡µé¢ï¼Œè·³è½¬åˆ°é¦–é¡µ
    if (hasRole && !canAccessPage(pathname)) {
      router.push('/');
      return;
    }
  }, [isLoading, hasRole, pathname, canAccessPage, router]);

  if (isLoading) {
    return <div>åŠ è½½ä¸­...</div>;
  }

  return <>{children}</>;
}
```

## ğŸš€ ä½¿ç”¨ç¤ºä¾‹

### 1. æ§åˆ¶å™¨ä¸­ä½¿ç”¨æƒé™æ£€æŸ¥
```typescript
@Controller('users')
@UseGuards(JwtAuthGuard, PermissionsGuard)
export class UsersController {
  
  @Get()
  @CheckPermissions('user.read')
  findAll() {
    return this.usersService.findAll();
  }

  @Post()
  @CheckPermissions('user.create')
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Delete(':id')
  @CheckPermissions('user.delete')
  @UseGuards(AdminGuard) // é¢å¤–çš„ç®¡ç†å‘˜æƒé™æ£€æŸ¥
  remove(@Param('id') id: string) {
    return this.usersService.remove(+id);
  }
}
```

### 2. å‰ç«¯ç»„ä»¶ä¸­ä½¿ç”¨æƒé™
```typescript
export function UserManagement() {
  const { canPerformAction } = useContext(PermissionContext);

  return (
    <div>
      <h1>ç”¨æˆ·ç®¡ç†</h1>
      
      {canPerformAction('user.create') && (
        <Button onClick={handleCreate}>æ–°å¢ç”¨æˆ·</Button>
      )}
      
      <Table>
        {users.map(user => (
          <tr key={user.id}>
            <td>{user.username}</td>
            <td>
              {canPerformAction('user.update') && (
                <Button onClick={() => handleEdit(user.id)}>ç¼–è¾‘</Button>
              )}
              {canPerformAction('user.delete') && (
                <Button onClick={() => handleDelete(user.id)}>åˆ é™¤</Button>
              )}
            </td>
          </tr>
        ))}
      </Table>
    </div>
  );
}
```

## ğŸ“Š æƒé™æ•°æ®åˆå§‹åŒ–

### é»˜è®¤æƒé™é…ç½®
```typescript
export const DEFAULT_PERMISSIONS = [
  // èœå•æƒé™
  { code: 'menu.users', name: 'ç”¨æˆ·ç®¡ç†', type: 'menu' },
  { code: 'menu.roles', name: 'è§’è‰²ç®¡ç†', type: 'menu' },
  { code: 'menu.permissions', name: 'æƒé™ç®¡ç†', type: 'menu' },
  { code: 'menu.customer', name: 'å®¢æˆ·ç®¡ç†', type: 'menu' },
  { code: 'menu.receipts', name: 'ç­¾æ”¶å•ç®¡ç†', type: 'menu' },
  { code: 'menu.wxuser', name: 'å°ç¨‹åºç”¨æˆ·', type: 'menu' },
  
  // æ“ä½œæƒé™
  { code: 'user.create', name: 'åˆ›å»ºç”¨æˆ·', type: 'action' },
  { code: 'user.read', name: 'æŸ¥çœ‹ç”¨æˆ·', type: 'action' },
  { code: 'user.update', name: 'æ›´æ–°ç”¨æˆ·', type: 'action' },
  { code: 'user.delete', name: 'åˆ é™¤ç”¨æˆ·', type: 'action' },
  
  { code: 'role.create', name: 'åˆ›å»ºè§’è‰²', type: 'action' },
  { code: 'role.read', name: 'æŸ¥çœ‹è§’è‰²', type: 'action' },
  { code: 'role.update', name: 'æ›´æ–°è§’è‰²', type: 'action' },
  { code: 'role.delete', name: 'åˆ é™¤è§’è‰²', type: 'action' },
];

export const DEFAULT_ROLES = [
  {
    code: 'admin',
    name: 'è¶…çº§ç®¡ç†å‘˜',
    description: 'æ‹¥æœ‰ç³»ç»Ÿæ‰€æœ‰æƒé™',
    permissions: DEFAULT_PERMISSIONS.map(p => p.code)
  },
  {
    code: 'operator',
    name: 'æ“ä½œå‘˜',
    description: 'åŸºç¡€æ“ä½œæƒé™',
    permissions: [
      'menu.customer',
      'menu.receipts',
      'customer.read',
      'receipt.read'
    ]
  }
];
```

---

**ç›¸å…³æ–‡æ¡£**:
- [ç”¨æˆ·è®¤è¯æ¨¡å—å®ç°](./ç”¨æˆ·è®¤è¯æ¨¡å—å®ç°.md)
- [æ•°æ®åº“è®¾è®¡](../01-æ¶æ„è®¾è®¡/æ•°æ®åº“è®¾è®¡.md)
- [å®‰å…¨è®¤è¯æŒ‡å—](../03-å®‰å…¨è®¤è¯/)
