# 🔐 用户认证模块实现详解

## 📋 模块概述

用户认证模块是系统的核心安全模块，负责处理用户登录、权限验证、Token管理等功能。采用JWT无状态认证机制，支持管理后台和小程序双端认证。

## 🏗️ 模块架构

### 目录结构
```
backend-node/src/auth/
├── auth.controller.ts          # 认证控制器
├── auth.service.ts            # 认证服务
├── auth.module.ts             # 认证模块
├── strategies/
│   └── jwt.strategy.ts        # JWT策略
├── guards/
│   ├── jwt-auth.guard.ts      # JWT认证守卫
│   └── admin.guard.ts         # 管理员权限守卫
├── decorators/
│   ├── public.decorator.ts    # 公开接口装饰器
│   ├── admin-only.decorator.ts # 管理员专用装饰器
│   └── dev-bypass.decorator.ts # 开发环境绕过装饰器
├── dto/
│   ├── login.dto.ts           # 登录DTO
│   └── token.dto.ts           # Token DTO
└── services/
    ├── blacklist.service.ts   # Token黑名单服务
    ├── captcha.service.ts     # 验证码服务
    ├── signature.service.ts   # 签名服务
    └── token.service.ts       # Token管理服务
```

## 🔑 核心实现

### 1. JWT策略实现

```typescript
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private configService: ConfigService,
    private usersService: UsersService,
    private wxUsersService: WxUsersService,
    private blacklistService: BlacklistService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET || 'logistics-system-jwt-secret-2024',
      passReqToCallback: true, // 允许在validate方法中访问request
    });
  }

  async validate(req: any, payload: JwtPayload) {
    // 检查payload是否有效
    if (!payload || !payload.sub || typeof payload.sub !== 'number') {
      throw new UnauthorizedException('Token格式无效');
    }

    // 检查token是否在黑名单中
    const authHeader = req.headers.authorization;
    const token = this.blacklistService.extractToken(authHeader);

    if (token && this.blacklistService.isBlacklisted(token)) {
      throw new UnauthorizedException('Token已失效，请重新登录');
    }

    // 根据用户类型查找用户
    let user;
    if (payload.userType === 'wx-user') {
      // 小程序用户
      user = await this.wxUsersService.findOne(payload.sub);
      if (!user) {
        throw new UnauthorizedException('小程序用户不存在');
      }
    } else {
      // 管理后台用户
      user = await this.usersService.findOne(payload.sub);
      if (!user) {
        throw new UnauthorizedException('用户不存在');
      }
    }

    return user;
  }
}
```

### 2. 认证守卫实现

```typescript
@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    // 检查是否为公开接口
    const isPublic = this.reflector.getAllAndOverride<boolean>('isPublic', [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) {
      return true;
    }

    // 开发环境认证绕过检查
    const canDevBypass = this.reflector.getAllAndOverride<boolean>(DEV_BYPASS_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (canDevBypass && process.env.NODE_ENV !== 'production') {
      const request = context.switchToHttp().getRequest();
      const skipAuth = request.headers['x-dev-skip-auth'];

      // 如果请求头中 X-Dev-Skip-Auth 为 'false'，则跳过认证
      if (skipAuth === 'false') {
        console.log('🔓 [开发模式] 跳过JWT认证验证');
        return true;
      }
    }

    return super.canActivate(context);
  }
}
```

### 3. 管理员权限守卫

```typescript
@Injectable()
export class AdminGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private permissionCheckService: PermissionCheckService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // 检查是否需要管理员权限
    const requireAdmin = this.reflector.getAllAndOverride<boolean>(ADMIN_ONLY_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requireAdmin) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user) {
      throw new ForbiddenException('用户未登录');
    }

    // 检查用户是否为超级管理员
    const isAdmin = await this.permissionCheckService.isAdmin(user.id);
    
    if (!isAdmin) {
      throw new ForbiddenException('只有超级管理员才能执行此操作');
    }

    return true;
  }
}
```

## 🔒 安全机制

### 1. 密码加密
```typescript
// 密码加密
const saltRounds = 12;
const hashedPassword = await bcrypt.hash(password, saltRounds);

// 密码验证
const isValid = await bcrypt.compare(password, hashedPassword);
```

### 2. Token黑名单机制
```typescript
@Injectable()
export class BlacklistService {
  private blacklistedTokens = new Set<string>();

  addToBlacklist(token: string): void {
    this.blacklistedTokens.add(token);
  }

  isBlacklisted(token: string): boolean {
    return this.blacklistedTokens.has(token);
  }

  extractToken(authHeader: string): string | null {
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return null;
    }
    return authHeader.substring(7);
  }
}
```

### 3. 验证码服务
```typescript
@Injectable()
export class CaptchaService {
  private captchaStore = new Map<string, { code: string; expires: number }>();

  generateCaptcha(): { id: string; svg: string } {
    const captcha = svgCaptcha.create({
      size: 4,
      noise: 2,
      color: true,
      background: '#f0f0f0',
    });

    const id = this.generateId();
    const expires = Date.now() + 5 * 60 * 1000; // 5分钟过期

    this.captchaStore.set(id, {
      code: captcha.text.toLowerCase(),
      expires,
    });

    return { id, svg: captcha.data };
  }

  verifyCaptcha(id: string, code: string): boolean {
    const stored = this.captchaStore.get(id);
    
    if (!stored) {
      return false;
    }

    // 检查是否过期
    if (Date.now() > stored.expires) {
      this.captchaStore.delete(id);
      return false;
    }

    // 验证验证码
    const isValid = stored.code === code.toLowerCase();
    
    // 验证后删除
    this.captchaStore.delete(id);
    
    return isValid;
  }
}
```

## 🎯 使用示例

### 1. 控制器中使用认证
```typescript
@Controller('users')
@UseGuards(JwtAuthGuard) // 应用JWT认证守卫
export class UsersController {
  
  @Get('profile')
  getProfile(@Req() req) {
    return req.user; // 获取当前登录用户
  }

  @Post('admin-only')
  @UseGuards(AdminGuard) // 需要管理员权限
  adminOnlyAction() {
    return { message: '管理员专用操作' };
  }

  @Get('public')
  @Public() // 公开接口，无需认证
  publicEndpoint() {
    return { message: '公开接口' };
  }
}
```

### 2. 小程序认证使用
```typescript
@Controller('miniprogram')
@UseGuards(JwtAuthGuard)
export class MiniprogramController {
  
  @Post('login')
  @Public()
  async login(@Body() loginDto: SimpleLoginDto) {
    // 小程序登录逻辑
    const user = await this.wxUsersService.findByPhone(loginDto.phone);
    
    // 生成JWT Token
    const payload = { 
      sub: user.id, 
      username: user.name,
      userType: 'wx-user'
    };
    
    const accessToken = this.jwtService.sign(payload);
    
    return {
      code: 200,
      message: '登录成功',
      data: { accessToken, user }
    };
  }
}
```

## 🔧 配置说明

### 1. JWT配置
```typescript
// auth.module.ts
JwtModule.register({
  secret: process.env.JWT_SECRET || 'logistics-system-jwt-secret-2024',
  signOptions: {
    expiresIn: process.env.JWT_EXPIRES_IN || '30d'
  },
})
```

### 2. 环境变量
```env
# JWT配置
JWT_SECRET=logistics-system-jwt-secret-2024
JWT_EXPIRES_IN=30d

# 开发环境配置
NODE_ENV=development
```

## 🚨 注意事项

1. **生产环境安全**
   - 必须使用强密码作为JWT_SECRET
   - 定期轮换密钥
   - 启用HTTPS传输

2. **Token管理**
   - 合理设置Token过期时间
   - 实现Token刷新机制
   - 用户登出时加入黑名单

3. **权限控制**
   - 最小权限原则
   - 定期审查用户权限
   - 记录敏感操作日志

## 📊 性能优化

1. **缓存策略**
   - 用户权限信息缓存
   - 验证码内存存储
   - Token黑名单优化

2. **数据库优化**
   - 用户表索引优化
   - 权限查询优化
   - 连接池配置

---

**相关文档**:
- [权限管理模块实现](./权限管理模块实现.md)
- [小程序认证实现](./小程序认证模块实现.md)
- [安全配置指南](../03-安全认证/)
