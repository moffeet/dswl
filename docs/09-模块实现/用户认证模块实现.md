# ğŸ” ç”¨æˆ·è®¤è¯æ¨¡å—å®ç°è¯¦è§£

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

ç”¨æˆ·è®¤è¯æ¨¡å—æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒå®‰å…¨æ¨¡å—ï¼Œè´Ÿè´£å¤„ç†ç”¨æˆ·ç™»å½•ã€æƒé™éªŒè¯ã€Tokenç®¡ç†ç­‰åŠŸèƒ½ã€‚é‡‡ç”¨JWTæ— çŠ¶æ€è®¤è¯æœºåˆ¶ï¼Œæ”¯æŒç®¡ç†åå°å’Œå°ç¨‹åºåŒç«¯è®¤è¯ã€‚

## ğŸ—ï¸ æ¨¡å—æ¶æ„

### ç›®å½•ç»“æ„
```
backend-node/src/auth/
â”œâ”€â”€ auth.controller.ts          # è®¤è¯æ§åˆ¶å™¨
â”œâ”€â”€ auth.service.ts            # è®¤è¯æœåŠ¡
â”œâ”€â”€ auth.module.ts             # è®¤è¯æ¨¡å—
â”œâ”€â”€ strategies/
â”‚   â””â”€â”€ jwt.strategy.ts        # JWTç­–ç•¥
â”œâ”€â”€ guards/
â”‚   â”œâ”€â”€ jwt-auth.guard.ts      # JWTè®¤è¯å®ˆå«
â”‚   â””â”€â”€ admin.guard.ts         # ç®¡ç†å‘˜æƒé™å®ˆå«
â”œâ”€â”€ decorators/
â”‚   â”œâ”€â”€ public.decorator.ts    # å…¬å¼€æ¥å£è£…é¥°å™¨
â”‚   â”œâ”€â”€ admin-only.decorator.ts # ç®¡ç†å‘˜ä¸“ç”¨è£…é¥°å™¨
â”‚   â””â”€â”€ dev-bypass.decorator.ts # å¼€å‘ç¯å¢ƒç»•è¿‡è£…é¥°å™¨
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ login.dto.ts           # ç™»å½•DTO
â”‚   â””â”€â”€ token.dto.ts           # Token DTO
â””â”€â”€ services/
    â”œâ”€â”€ blacklist.service.ts   # Tokené»‘åå•æœåŠ¡
    â”œâ”€â”€ captcha.service.ts     # éªŒè¯ç æœåŠ¡
    â”œâ”€â”€ signature.service.ts   # ç­¾åæœåŠ¡
    â””â”€â”€ token.service.ts       # Tokenç®¡ç†æœåŠ¡
```

## ğŸ”‘ æ ¸å¿ƒå®ç°

### 1. JWTç­–ç•¥å®ç°

```typescript
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private configService: ConfigService,
    private usersService: UsersService,
    private wxUsersService: WxUsersService,
    private blacklistService: BlacklistService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET || 'logistics-system-jwt-secret-2024',
      passReqToCallback: true, // å…è®¸åœ¨validateæ–¹æ³•ä¸­è®¿é—®request
    });
  }

  async validate(req: any, payload: JwtPayload) {
    // æ£€æŸ¥payloadæ˜¯å¦æœ‰æ•ˆ
    if (!payload || !payload.sub || typeof payload.sub !== 'number') {
      throw new UnauthorizedException('Tokenæ ¼å¼æ— æ•ˆ');
    }

    // æ£€æŸ¥tokenæ˜¯å¦åœ¨é»‘åå•ä¸­
    const authHeader = req.headers.authorization;
    const token = this.blacklistService.extractToken(authHeader);

    if (token && this.blacklistService.isBlacklisted(token)) {
      throw new UnauthorizedException('Tokenå·²å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•');
    }

    // æ ¹æ®ç”¨æˆ·ç±»å‹æŸ¥æ‰¾ç”¨æˆ·
    let user;
    if (payload.userType === 'wx-user') {
      // å°ç¨‹åºç”¨æˆ·
      user = await this.wxUsersService.findOne(payload.sub);
      if (!user) {
        throw new UnauthorizedException('å°ç¨‹åºç”¨æˆ·ä¸å­˜åœ¨');
      }
    } else {
      // ç®¡ç†åå°ç”¨æˆ·
      user = await this.usersService.findOne(payload.sub);
      if (!user) {
        throw new UnauthorizedException('ç”¨æˆ·ä¸å­˜åœ¨');
      }
    }

    return user;
  }
}
```

### 2. è®¤è¯å®ˆå«å®ç°

```typescript
@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    // æ£€æŸ¥æ˜¯å¦ä¸ºå…¬å¼€æ¥å£
    const isPublic = this.reflector.getAllAndOverride<boolean>('isPublic', [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) {
      return true;
    }

    // å¼€å‘ç¯å¢ƒè®¤è¯ç»•è¿‡æ£€æŸ¥
    const canDevBypass = this.reflector.getAllAndOverride<boolean>(DEV_BYPASS_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (canDevBypass && process.env.NODE_ENV !== 'production') {
      const request = context.switchToHttp().getRequest();
      const skipAuth = request.headers['x-dev-skip-auth'];

      // å¦‚æœè¯·æ±‚å¤´ä¸­ X-Dev-Skip-Auth ä¸º 'false'ï¼Œåˆ™è·³è¿‡è®¤è¯
      if (skipAuth === 'false') {
        console.log('ğŸ”“ [å¼€å‘æ¨¡å¼] è·³è¿‡JWTè®¤è¯éªŒè¯');
        return true;
      }
    }

    return super.canActivate(context);
  }
}
```

### 3. ç®¡ç†å‘˜æƒé™å®ˆå«

```typescript
@Injectable()
export class AdminGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private permissionCheckService: PermissionCheckService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç®¡ç†å‘˜æƒé™
    const requireAdmin = this.reflector.getAllAndOverride<boolean>(ADMIN_ONLY_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requireAdmin) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user) {
      throw new ForbiddenException('ç”¨æˆ·æœªç™»å½•');
    }

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ä¸ºè¶…çº§ç®¡ç†å‘˜
    const isAdmin = await this.permissionCheckService.isAdmin(user.id);
    
    if (!isAdmin) {
      throw new ForbiddenException('åªæœ‰è¶…çº§ç®¡ç†å‘˜æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ');
    }

    return true;
  }
}
```

## ğŸ”’ å®‰å…¨æœºåˆ¶

### 1. å¯†ç åŠ å¯†
```typescript
// å¯†ç åŠ å¯†
const saltRounds = 12;
const hashedPassword = await bcrypt.hash(password, saltRounds);

// å¯†ç éªŒè¯
const isValid = await bcrypt.compare(password, hashedPassword);
```

### 2. Tokené»‘åå•æœºåˆ¶
```typescript
@Injectable()
export class BlacklistService {
  private blacklistedTokens = new Set<string>();

  addToBlacklist(token: string): void {
    this.blacklistedTokens.add(token);
  }

  isBlacklisted(token: string): boolean {
    return this.blacklistedTokens.has(token);
  }

  extractToken(authHeader: string): string | null {
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return null;
    }
    return authHeader.substring(7);
  }
}
```

### 3. éªŒè¯ç æœåŠ¡
```typescript
@Injectable()
export class CaptchaService {
  private captchaStore = new Map<string, { code: string; expires: number }>();

  generateCaptcha(): { id: string; svg: string } {
    const captcha = svgCaptcha.create({
      size: 4,
      noise: 2,
      color: true,
      background: '#f0f0f0',
    });

    const id = this.generateId();
    const expires = Date.now() + 5 * 60 * 1000; // 5åˆ†é’Ÿè¿‡æœŸ

    this.captchaStore.set(id, {
      code: captcha.text.toLowerCase(),
      expires,
    });

    return { id, svg: captcha.data };
  }

  verifyCaptcha(id: string, code: string): boolean {
    const stored = this.captchaStore.get(id);
    
    if (!stored) {
      return false;
    }

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() > stored.expires) {
      this.captchaStore.delete(id);
      return false;
    }

    // éªŒè¯éªŒè¯ç 
    const isValid = stored.code === code.toLowerCase();
    
    // éªŒè¯ååˆ é™¤
    this.captchaStore.delete(id);
    
    return isValid;
  }
}
```

## ğŸ¯ ä½¿ç”¨ç¤ºä¾‹

### 1. æ§åˆ¶å™¨ä¸­ä½¿ç”¨è®¤è¯
```typescript
@Controller('users')
@UseGuards(JwtAuthGuard) // åº”ç”¨JWTè®¤è¯å®ˆå«
export class UsersController {
  
  @Get('profile')
  getProfile(@Req() req) {
    return req.user; // è·å–å½“å‰ç™»å½•ç”¨æˆ·
  }

  @Post('admin-only')
  @UseGuards(AdminGuard) // éœ€è¦ç®¡ç†å‘˜æƒé™
  adminOnlyAction() {
    return { message: 'ç®¡ç†å‘˜ä¸“ç”¨æ“ä½œ' };
  }

  @Get('public')
  @Public() // å…¬å¼€æ¥å£ï¼Œæ— éœ€è®¤è¯
  publicEndpoint() {
    return { message: 'å…¬å¼€æ¥å£' };
  }
}
```

### 2. å°ç¨‹åºè®¤è¯ä½¿ç”¨
```typescript
@Controller('miniprogram')
@UseGuards(JwtAuthGuard)
export class MiniprogramController {
  
  @Post('login')
  @Public()
  async login(@Body() loginDto: SimpleLoginDto) {
    // å°ç¨‹åºç™»å½•é€»è¾‘
    const user = await this.wxUsersService.findByPhone(loginDto.phone);
    
    // ç”ŸæˆJWT Token
    const payload = { 
      sub: user.id, 
      username: user.name,
      userType: 'wx-user'
    };
    
    const accessToken = this.jwtService.sign(payload);
    
    return {
      code: 200,
      message: 'ç™»å½•æˆåŠŸ',
      data: { accessToken, user }
    };
  }
}
```

## ğŸ”§ é…ç½®è¯´æ˜

### 1. JWTé…ç½®
```typescript
// auth.module.ts
JwtModule.register({
  secret: process.env.JWT_SECRET || 'logistics-system-jwt-secret-2024',
  signOptions: {
    expiresIn: process.env.JWT_EXPIRES_IN || '30d'
  },
})
```

### 2. ç¯å¢ƒå˜é‡
```env
# JWTé…ç½®
JWT_SECRET=logistics-system-jwt-secret-2024
JWT_EXPIRES_IN=30d

# å¼€å‘ç¯å¢ƒé…ç½®
NODE_ENV=development
```

## ğŸš¨ æ³¨æ„äº‹é¡¹

1. **ç”Ÿäº§ç¯å¢ƒå®‰å…¨**
   - å¿…é¡»ä½¿ç”¨å¼ºå¯†ç ä½œä¸ºJWT_SECRET
   - å®šæœŸè½®æ¢å¯†é’¥
   - å¯ç”¨HTTPSä¼ è¾“

2. **Tokenç®¡ç†**
   - åˆç†è®¾ç½®Tokenè¿‡æœŸæ—¶é—´
   - å®ç°Tokenåˆ·æ–°æœºåˆ¶
   - ç”¨æˆ·ç™»å‡ºæ—¶åŠ å…¥é»‘åå•

3. **æƒé™æ§åˆ¶**
   - æœ€å°æƒé™åŸåˆ™
   - å®šæœŸå®¡æŸ¥ç”¨æˆ·æƒé™
   - è®°å½•æ•æ„Ÿæ“ä½œæ—¥å¿—

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

1. **ç¼“å­˜ç­–ç•¥**
   - ç”¨æˆ·æƒé™ä¿¡æ¯ç¼“å­˜
   - éªŒè¯ç å†…å­˜å­˜å‚¨
   - Tokené»‘åå•ä¼˜åŒ–

2. **æ•°æ®åº“ä¼˜åŒ–**
   - ç”¨æˆ·è¡¨ç´¢å¼•ä¼˜åŒ–
   - æƒé™æŸ¥è¯¢ä¼˜åŒ–
   - è¿æ¥æ± é…ç½®

---

**ç›¸å…³æ–‡æ¡£**:
- [æƒé™ç®¡ç†æ¨¡å—å®ç°](./æƒé™ç®¡ç†æ¨¡å—å®ç°.md)
- [å°ç¨‹åºè®¤è¯å®ç°](./å°ç¨‹åºè®¤è¯æ¨¡å—å®ç°.md)
- [å®‰å…¨é…ç½®æŒ‡å—](../03-å®‰å…¨è®¤è¯/)
