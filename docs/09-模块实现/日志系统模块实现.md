# ğŸ“Š æ—¥å¿—ç³»ç»Ÿæ¨¡å—å®ç°è¯¦è§£

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

æ—¥å¿—ç³»ç»Ÿæ¨¡å—æ˜¯ç³»ç»Ÿç›‘æ§å’Œè°ƒè¯•çš„æ ¸å¿ƒç»„ä»¶ï¼Œæä¾›ç»“æ„åŒ–æ—¥å¿—è®°å½•ã€æ—¥å¿—è½®è½¬ã€è¿½è¸ªIDå…³è”ã€æ€§èƒ½ç›‘æ§ç­‰åŠŸèƒ½ã€‚é‡‡ç”¨Winstonæ—¥å¿—åº“ï¼Œæ”¯æŒå¤šç§è¾“å‡ºæ ¼å¼å’Œå­˜å‚¨æ–¹å¼ã€‚

## ğŸ—ï¸ æ¨¡å—æ¶æ„

### ç›®å½•ç»“æ„
```
backend-node/src/config/
â”œâ”€â”€ logger.config.ts            # æ—¥å¿—é…ç½®
â””â”€â”€ trace-id.config.ts          # è¿½è¸ªIDé…ç½®

backend-node/src/common/
â”œâ”€â”€ middleware/
â”‚   â””â”€â”€ trace-id.middleware.ts  # è¿½è¸ªIDä¸­é—´ä»¶
â”œâ”€â”€ interceptors/
â”‚   â””â”€â”€ logging.interceptor.ts  # æ—¥å¿—æ‹¦æˆªå™¨
â”œâ”€â”€ filters/
â”‚   â””â”€â”€ global-exception.filter.ts # å…¨å±€å¼‚å¸¸è¿‡æ»¤å™¨
â””â”€â”€ controllers/
    â””â”€â”€ logs.controller.ts      # æ—¥å¿—ç®¡ç†æ§åˆ¶å™¨
```

### æ—¥å¿—æ–‡ä»¶ç»“æ„
```
logs/
â”œâ”€â”€ backend.log                 # å½“å‰æ—¥å¿—æ–‡ä»¶
â”œâ”€â”€ backend-2025-W28.log       # æŒ‰å‘¨è½®è½¬çš„æ—¥å¿—
â”œâ”€â”€ database.log               # æ•°æ®åº“æ—¥å¿—
â”œâ”€â”€ error.log                  # é”™è¯¯æ—¥å¿—
â””â”€â”€ combined.log               # ç»¼åˆæ—¥å¿—
```

## ğŸ”§ æ ¸å¿ƒé…ç½®å®ç°

### æ—¥å¿—é…ç½® (LoggerConfig)
```typescript
import * as winston from 'winston';
import * as DailyRotateFile from 'winston-daily-rotate-file';
import { Injectable, LoggerService } from '@nestjs/common';

/**
 * è¿½è¸ªIDç®¡ç†å™¨
 */
export class TraceIdManager {
  private static traceIdMap = new Map<string, string>();

  static generateTraceId(): string {
    return `trace_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }

  static setTraceId(key: string, traceId: string): void {
    this.traceIdMap.set(key, traceId);
  }

  static getTraceId(key: string): string | undefined {
    return this.traceIdMap.get(key);
  }

  static clearTraceId(key: string): void {
    this.traceIdMap.delete(key);
  }
}

/**
 * è‡ªå®šä¹‰æ—¥å¿—æ ¼å¼åŒ–å™¨
 */
const customFormat = winston.format.combine(
  winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss.SSS'
  }),
  winston.format.errors({ stack: true }),
  winston.format.printf(({ timestamp, level, message, context, traceId, stack, ...meta }) => {
    const traceInfo = traceId ? `[${traceId}]` : '';
    const contextInfo = context ? `[${context}]` : '';
    const metaInfo = Object.keys(meta).length ? ` ${JSON.stringify(meta)}` : '';
    const stackInfo = stack ? `\n${stack}` : '';
    
    return `${timestamp} [${level.toUpperCase()}] ${traceInfo}${contextInfo} ${message}${metaInfo}${stackInfo}`;
  })
);

/**
 * è‡ªå®šä¹‰Loggerç±»
 */
@Injectable()
export class CustomLogger implements LoggerService {
  private readonly winston: winston.Logger;
  private context?: string;

  constructor(context?: string) {
    this.context = context;
    this.winston = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: customFormat,
      transports: [
        // æ§åˆ¶å°è¾“å‡º
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            customFormat
          )
        }),

        // åº”ç”¨æ—¥å¿—æ–‡ä»¶ï¼ˆæŒ‰æ—¥è½®è½¬ï¼‰
        new DailyRotateFile({
          filename: 'logs/backend-%DATE%.log',
          datePattern: 'YYYY-[W]WW', // æŒ‰å‘¨è½®è½¬
          maxSize: '20m',
          maxFiles: '14d',
          format: customFormat,
          auditFile: 'logs/backend-audit.json'
        }),

        // é”™è¯¯æ—¥å¿—æ–‡ä»¶
        new DailyRotateFile({
          filename: 'logs/error-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          maxSize: '20m',
          maxFiles: '30d',
          level: 'error',
          format: customFormat
        }),

        // ç»¼åˆæ—¥å¿—æ–‡ä»¶
        new winston.transports.File({
          filename: 'logs/combined.log',
          maxsize: 50 * 1024 * 1024, // 50MB
          maxFiles: 5,
          format: customFormat
        })
      ],
      
      // å¼‚å¸¸å¤„ç†
      exceptionHandlers: [
        new winston.transports.File({ filename: 'logs/exceptions.log' })
      ],
      
      // æœªæ•è·çš„Promiseæ‹’ç»
      rejectionHandlers: [
        new winston.transports.File({ filename: 'logs/rejections.log' })
      ]
    });
  }

  /**
   * è®°å½•æ™®é€šæ—¥å¿—
   */
  log(message: string, context?: string, traceId?: string): void {
    this.winston.info(message, {
      context: context || this.context,
      traceId
    });
  }

  /**
   * è®°å½•é”™è¯¯æ—¥å¿—
   */
  error(message: string, stack?: string, context?: string, traceId?: string): void {
    this.winston.error(message, {
      context: context || this.context,
      stack,
      traceId
    });
  }

  /**
   * è®°å½•è­¦å‘Šæ—¥å¿—
   */
  warn(message: string, context?: string, traceId?: string): void {
    this.winston.warn(message, {
      context: context || this.context,
      traceId
    });
  }

  /**
   * è®°å½•è°ƒè¯•æ—¥å¿—
   */
  debug(message: string, context?: string, traceId?: string): void {
    this.winston.debug(message, {
      context: context || this.context,
      traceId
    });
  }

  /**
   * è®°å½•è¯¦ç»†æ—¥å¿—
   */
  verbose(message: string, context?: string, traceId?: string): void {
    this.winston.verbose(message, {
      context: context || this.context,
      traceId
    });
  }

  /**
   * è®°å½•æ€§èƒ½æ—¥å¿—
   */
  performance(operation: string, duration: number, context?: string, traceId?: string): void {
    this.winston.info(`æ€§èƒ½ç›‘æ§ - ${operation}: ${duration}ms`, {
      context: context || this.context,
      traceId,
      performance: {
        operation,
        duration,
        timestamp: new Date().toISOString()
      }
    });
  }

  /**
   * è®°å½•ä¸šåŠ¡æ—¥å¿—
   */
  business(action: string, details: any, context?: string, traceId?: string): void {
    this.winston.info(`ä¸šåŠ¡æ“ä½œ - ${action}`, {
      context: context || this.context,
      traceId,
      business: {
        action,
        details,
        timestamp: new Date().toISOString()
      }
    });
  }
}

/**
 * æ•°æ®åº“æ—¥å¿—è®°å½•å™¨
 */
export class DatabaseLogger implements winston.Logger {
  private readonly winston: winston.Logger;

  constructor() {
    this.winston = winston.createLogger({
      level: 'info',
      format: customFormat,
      transports: [
        new DailyRotateFile({
          filename: 'logs/database-%DATE%.log',
          datePattern: 'YYYY-[W]WW',
          maxSize: '20m',
          maxFiles: '14d',
          format: customFormat
        })
      ]
    });
  }

  logQuery(query: string, parameters?: any[], queryRunner?: any): void {
    this.winston.info('SQLæŸ¥è¯¢', {
      context: 'Database',
      query: query.replace(/\s+/g, ' ').trim(),
      parameters,
      duration: queryRunner?.duration || 0
    });
  }

  logQueryError(error: string, query: string, parameters?: any[], queryRunner?: any): void {
    this.winston.error('SQLæŸ¥è¯¢é”™è¯¯', {
      context: 'Database',
      error,
      query: query.replace(/\s+/g, ' ').trim(),
      parameters,
      stack: error
    });
  }

  logQuerySlow(time: number, query: string, parameters?: any[], queryRunner?: any): void {
    this.winston.warn(`æ…¢æŸ¥è¯¢ - è€—æ—¶: ${time}ms`, {
      context: 'Database',
      query: query.replace(/\s+/g, ' ').trim(),
      parameters,
      duration: time
    });
  }

  logSchemaBuild(message: string, queryRunner?: any): void {
    this.winston.info(`æ•°æ®åº“æ¶æ„ - ${message}`, {
      context: 'Database'
    });
  }

  logMigration(message: string, queryRunner?: any): void {
    this.winston.info(`æ•°æ®åº“è¿ç§» - ${message}`, {
      context: 'Database'
    });
  }

  log(level: string, message: string, queryRunner?: any): void {
    this.winston.log(level, message, {
      context: 'Database'
    });
  }
}
```

## ğŸ” è¿½è¸ªIDä¸­é—´ä»¶

### è¿½è¸ªIDä¸­é—´ä»¶ (TraceIdMiddleware)
```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { TraceIdManager } from '../../config/logger.config';

// æ‰©å±•Requestæ¥å£
declare global {
  namespace Express {
    interface Request {
      traceId?: string;
    }
  }
}

/**
 * è¯·æ±‚è¿½è¸ªIDä¸­é—´ä»¶
 * ä¸ºæ¯ä¸ªHTTPè¯·æ±‚ç”Ÿæˆå”¯ä¸€çš„è¿½è¸ªIDï¼Œç”¨äºæ—¥å¿—å…³è”
 */
@Injectable()
export class TraceIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // ç”Ÿæˆå”¯ä¸€çš„è¿½è¸ªID
    const traceId = TraceIdManager.generateTraceId();
    
    // å°†traceIdæ·»åŠ åˆ°è¯·æ±‚å¯¹è±¡
    req.traceId = traceId;
    
    // å°†traceIdæ·»åŠ åˆ°å“åº”å¤´ï¼ˆä¾¿äºè°ƒè¯•ï¼‰
    res.setHeader('X-Trace-Id', traceId);
    
    // å­˜å‚¨åˆ°TraceIdManagerä¸­
    TraceIdManager.setTraceId(req.url, traceId);
    
    // è¯·æ±‚ç»“æŸæ—¶æ¸…ç†
    res.on('finish', () => {
      TraceIdManager.clearTraceId(req.url);
    });
    
    next();
  }
}
```

## ğŸ“Š æ—¥å¿—æ‹¦æˆªå™¨

### æ—¥å¿—æ‹¦æˆªå™¨ (LoggingInterceptor)
```typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
import { Request, Response } from 'express';
import { CustomLogger } from '../../config/logger.config';

/**
 * æ—¥å¿—æ‹¦æˆªå™¨
 * è‡ªåŠ¨è®°å½•HTTPè¯·æ±‚å’Œå“åº”çš„è¯¦ç»†ä¿¡æ¯
 */
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new CustomLogger('HTTP');

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const ctx = context.switchToHttp();
    const request = ctx.getRequest<Request>();
    const response = ctx.getResponse<Response>();
    
    const { method, url, headers, body, query, params } = request;
    const traceId = request.traceId;
    const userAgent = headers['user-agent'] || '';
    const ip = this.getClientIp(request);
    const startTime = Date.now();

    // è®°å½•è¯·æ±‚å¼€å§‹æ—¥å¿—
    this.logger.log(
      `è¯·æ±‚å¼€å§‹ ${method} ${url}`,
      'HTTP',
      traceId
    );

    // è®°å½•è¯¦ç»†çš„è¯·æ±‚ä¿¡æ¯ï¼ˆè°ƒè¯•çº§åˆ«ï¼‰
    if (process.env.NODE_ENV === 'development') {
      this.logger.debug(
        `è¯·æ±‚è¯¦æƒ… - IP: ${ip}, UserAgent: ${userAgent}, Query: ${JSON.stringify(query)}, Body: ${JSON.stringify(this.sanitizeBody(body))}`,
        'HTTP',
        traceId
      );
    }

    return next.handle().pipe(
      tap((data) => {
        // è¯·æ±‚æˆåŠŸå®Œæˆ
        const duration = Date.now() - startTime;
        const statusCode = response.statusCode;
        
        this.logger.log(
          `è¯·æ±‚å®Œæˆ ${method} ${url} - ${statusCode} - ${duration}ms`,
          'HTTP',
          traceId
        );

        // è®°å½•æ€§èƒ½æ—¥å¿—
        if (duration > 1000) {
          this.logger.performance(
            `${method} ${url}`,
            duration,
            'HTTP',
            traceId
          );
        }

        // è®°å½•å“åº”è¯¦æƒ…ï¼ˆä»…åœ¨è°ƒè¯•æ¨¡å¼ï¼‰
        if (process.env.NODE_ENV === 'development') {
          this.logger.debug(
            `å“åº”è¯¦æƒ… - çŠ¶æ€ç : ${statusCode}, è€—æ—¶: ${duration}ms, æ•°æ®å¤§å°: ${JSON.stringify(data).length} bytes`,
            'HTTP',
            traceId
          );
        }
      }),
      catchError((error) => {
        // è¯·æ±‚å¤„ç†å‡ºé”™
        const duration = Date.now() - startTime;
        const statusCode = error.status || 500;
        
        this.logger.error(
          `è¯·æ±‚å¤±è´¥ ${method} ${url} - ${statusCode} - ${duration}ms - ${error.message}`,
          error.stack,
          'HTTP',
          traceId
        );

        // é‡æ–°æŠ›å‡ºé”™è¯¯ï¼Œè®©å…¨å±€å¼‚å¸¸è¿‡æ»¤å™¨å¤„ç†
        throw error;
      })
    );
  }

  /**
   * è·å–å®¢æˆ·ç«¯IPåœ°å€
   */
  private getClientIp(request: Request): string {
    return (
      request.headers['x-forwarded-for'] as string ||
      request.headers['x-real-ip'] as string ||
      request.connection.remoteAddress ||
      request.socket.remoteAddress ||
      'unknown'
    );
  }

  /**
   * æ¸…ç†æ•æ„Ÿä¿¡æ¯
   */
  private sanitizeBody(body: any): any {
    if (!body || typeof body !== 'object') {
      return body;
    }

    const sensitiveFields = ['password', 'token', 'secret', 'key'];
    const sanitized = { ...body };

    for (const field of sensitiveFields) {
      if (sanitized[field]) {
        sanitized[field] = '***';
      }
    }

    return sanitized;
  }
}
```

## ğŸš¨ å…¨å±€å¼‚å¸¸è¿‡æ»¤å™¨

### å…¨å±€å¼‚å¸¸è¿‡æ»¤å™¨ (GlobalExceptionFilter)
```typescript
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { CustomLogger } from '../../config/logger.config';

/**
 * å…¨å±€å¼‚å¸¸è¿‡æ»¤å™¨
 * ç»Ÿä¸€å¤„ç†æ‰€æœ‰æœªæ•è·çš„å¼‚å¸¸ï¼Œæä¾›ä¸€è‡´çš„é”™è¯¯å“åº”æ ¼å¼
 */
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new CustomLogger('GlobalExceptionFilter');

  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // ä½¿ç”¨è¯·æ±‚ä¸­çš„è¿½è¸ªID
    const traceId = (request as any).traceId || this.generateTraceId();

    // è§£æå¼‚å¸¸ä¿¡æ¯
    const exceptionInfo = this.parseException(exception);

    // è®°å½•å¼‚å¸¸æ—¥å¿—
    this.logException(exception, request, traceId, exceptionInfo);

    // æ„å»ºå“åº”æ•°æ®
    const responseData = this.buildErrorResponse(exceptionInfo, request, traceId);

    // è¿”å›ç»Ÿä¸€æ ¼å¼çš„é”™è¯¯å“åº”
    response.status(exceptionInfo.httpStatus).json(responseData);
  }

  /**
   * è§£æå¼‚å¸¸ä¿¡æ¯
   */
  private parseException(exception: unknown): ExceptionInfo {
    if (exception instanceof HttpException) {
      return {
        httpStatus: exception.getStatus(),
        message: exception.message,
        name: exception.constructor.name,
        stack: exception.stack,
        details: exception.getResponse()
      };
    }

    if (exception instanceof Error) {
      return {
        httpStatus: HttpStatus.INTERNAL_SERVER_ERROR,
        message: exception.message || 'å†…éƒ¨æœåŠ¡å™¨é”™è¯¯',
        name: exception.constructor.name,
        stack: exception.stack,
        details: null
      };
    }

    return {
      httpStatus: HttpStatus.INTERNAL_SERVER_ERROR,
      message: 'æœªçŸ¥é”™è¯¯',
      name: 'UnknownError',
      stack: null,
      details: exception
    };
  }

  /**
   * è®°å½•å¼‚å¸¸æ—¥å¿—
   */
  private logException(
    exception: unknown,
    request: Request,
    traceId: string,
    exceptionInfo: ExceptionInfo
  ): void {
    const { method, url, headers, body } = request;
    const userAgent = headers['user-agent'] || '';
    const ip = this.getClientIp(request);

    // æ„å»ºæ—¥å¿—æ¶ˆæ¯
    const logMessage = `å¼‚å¸¸æ•è· ${method} ${url} - ${exceptionInfo.httpStatus} - ${exceptionInfo.message}`;
    
    // æ„å»ºè¯¦ç»†ä¿¡æ¯
    const logDetails = {
      exception: {
        name: exceptionInfo.name,
        message: exceptionInfo.message,
        httpStatus: exceptionInfo.httpStatus
      },
      request: {
        method,
        url,
        ip,
        userAgent,
        body: this.sanitizeBody(body)
      },
      timestamp: new Date().toISOString()
    };

    // æ ¹æ®å¼‚å¸¸ç±»å‹é€‰æ‹©æ—¥å¿—çº§åˆ«
    if (exceptionInfo.httpStatus >= 500) {
      // æœåŠ¡å™¨é”™è¯¯ - ERRORçº§åˆ«
      this.logger.error(
        logMessage,
        exceptionInfo.stack,
        'GlobalExceptionFilter',
        traceId
      );
    } else if (exceptionInfo.httpStatus >= 400) {
      // å®¢æˆ·ç«¯é”™è¯¯ - WARNçº§åˆ«
      this.logger.warn(
        logMessage,
        'GlobalExceptionFilter',
        traceId
      );
    } else {
      // å…¶ä»–æƒ…å†µ - INFOçº§åˆ«
      this.logger.log(
        logMessage,
        'GlobalExceptionFilter',
        traceId
      );
    }

    // è®°å½•è¯¦ç»†çš„å¼‚å¸¸ä¿¡æ¯ï¼ˆè°ƒè¯•æ¨¡å¼ï¼‰
    if (process.env.NODE_ENV === 'development') {
      this.logger.debug(
        `å¼‚å¸¸è¯¦æƒ…: ${JSON.stringify(logDetails, null, 2)}`,
        'GlobalExceptionFilter',
        traceId
      );
    }
  }

  /**
   * æ„å»ºé”™è¯¯å“åº”
   */
  private buildErrorResponse(
    exceptionInfo: ExceptionInfo,
    request: Request,
    traceId: string
  ): any {
    const baseResponse = {
      success: false,
      code: exceptionInfo.httpStatus,
      message: exceptionInfo.message,
      timestamp: new Date().toISOString(),
      path: request.url,
      traceId
    };

    // å¼€å‘ç¯å¢ƒè¿”å›æ›´å¤šè°ƒè¯•ä¿¡æ¯
    if (process.env.NODE_ENV === 'development') {
      return {
        ...baseResponse,
        error: exceptionInfo.name,
        details: exceptionInfo.details,
        stack: exceptionInfo.stack
      };
    }

    return baseResponse;
  }

  /**
   * è·å–å®¢æˆ·ç«¯IP
   */
  private getClientIp(request: Request): string {
    return (
      request.headers['x-forwarded-for'] as string ||
      request.headers['x-real-ip'] as string ||
      request.connection.remoteAddress ||
      'unknown'
    );
  }

  /**
   * æ¸…ç†æ•æ„Ÿä¿¡æ¯
   */
  private sanitizeBody(body: any): any {
    if (!body || typeof body !== 'object') {
      return body;
    }

    const sensitiveFields = ['password', 'token', 'secret', 'key'];
    const sanitized = { ...body };

    for (const field of sensitiveFields) {
      if (sanitized[field]) {
        sanitized[field] = '***';
      }
    }

    return sanitized;
  }

  /**
   * ç”Ÿæˆè¿½è¸ªID
   */
  private generateTraceId(): string {
    return `trace_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }
}

interface ExceptionInfo {
  httpStatus: number;
  message: string;
  name: string;
  stack?: string;
  details?: any;
}
```

## ğŸ“‹ æ—¥å¿—ç®¡ç†æ§åˆ¶å™¨

### æ—¥å¿—ç®¡ç†æ§åˆ¶å™¨ (LogsController)
```typescript
@ApiTags('æ—¥å¿—ç®¡ç†')
@Controller('logs')
@UseGuards(JwtAuthGuard, AdminGuard)
export class LogsController {
  private readonly logger = new CustomLogger('LogsController');

  /**
   * è·å–æ—¥å¿—æ–‡ä»¶åˆ—è¡¨
   */
  @Get('files')
  @ApiOperation({ summary: 'è·å–æ—¥å¿—æ–‡ä»¶åˆ—è¡¨' })
  async getLogFiles(): Promise<any> {
    try {
      const logsDir = path.join(process.cwd(), 'logs');
      const files = await fs.readdir(logsDir);
      
      const logFiles = await Promise.all(
        files
          .filter(file => file.endsWith('.log'))
          .map(async (file) => {
            const filePath = path.join(logsDir, file);
            const stats = await fs.stat(filePath);
            
            return {
              name: file,
              size: stats.size,
              modified: stats.mtime,
              created: stats.birthtime
            };
          })
      );

      return {
        success: true,
        data: logFiles.sort((a, b) => b.modified.getTime() - a.modified.getTime())
      };
    } catch (error) {
      this.logger.error(`è·å–æ—¥å¿—æ–‡ä»¶åˆ—è¡¨å¤±è´¥: ${error.message}`);
      throw new InternalServerErrorException('è·å–æ—¥å¿—æ–‡ä»¶åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * è¯»å–æ—¥å¿—æ–‡ä»¶å†…å®¹
   */
  @Get('files/:filename')
  @ApiOperation({ summary: 'è¯»å–æ—¥å¿—æ–‡ä»¶å†…å®¹' })
  async readLogFile(
    @Param('filename') filename: string,
    @Query('lines') lines: number = 100,
    @Query('offset') offset: number = 0
  ): Promise<any> {
    try {
      const logsDir = path.join(process.cwd(), 'logs');
      const filePath = path.join(logsDir, filename);

      // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿æ–‡ä»¶åœ¨logsç›®å½•å†…
      if (!filePath.startsWith(logsDir)) {
        throw new BadRequestException('æ— æ•ˆçš„æ–‡ä»¶è·¯å¾„');
      }

      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      if (!await fs.pathExists(filePath)) {
        throw new NotFoundException('æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨');
      }

      // è¯»å–æ–‡ä»¶å†…å®¹
      const content = await fs.readFile(filePath, 'utf-8');
      const allLines = content.split('\n');
      
      // åˆ†é¡µå¤„ç†
      const startIndex = Math.max(0, allLines.length - lines - offset);
      const endIndex = allLines.length - offset;
      const selectedLines = allLines.slice(startIndex, endIndex);

      return {
        success: true,
        data: {
          filename,
          totalLines: allLines.length,
          lines: selectedLines,
          hasMore: startIndex > 0
        }
      };
    } catch (error) {
      this.logger.error(`è¯»å–æ—¥å¿—æ–‡ä»¶å¤±è´¥: ${error.message}`);
      throw error;
    }
  }

  /**
   * æœç´¢æ—¥å¿—å†…å®¹
   */
  @Post('search')
  @ApiOperation({ summary: 'æœç´¢æ—¥å¿—å†…å®¹' })
  async searchLogs(@Body() searchDto: LogSearchDto): Promise<any> {
    try {
      const { keyword, filename, startDate, endDate, level } = searchDto;
      const logsDir = path.join(process.cwd(), 'logs');
      const filePath = path.join(logsDir, filename);

      if (!await fs.pathExists(filePath)) {
        throw new NotFoundException('æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨');
      }

      const content = await fs.readFile(filePath, 'utf-8');
      const lines = content.split('\n');
      
      // è¿‡æ»¤æ—¥å¿—è¡Œ
      const filteredLines = lines.filter(line => {
        if (!line.trim()) return false;
        
        // å…³é”®è¯æœç´¢
        if (keyword && !line.toLowerCase().includes(keyword.toLowerCase())) {
          return false;
        }
        
        // æ—¥å¿—çº§åˆ«è¿‡æ»¤
        if (level && !line.includes(`[${level.toUpperCase()}]`)) {
          return false;
        }
        
        // æ—¶é—´èŒƒå›´è¿‡æ»¤ï¼ˆç®€å•å®ç°ï¼‰
        if (startDate || endDate) {
          const timestampMatch = line.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/);
          if (timestampMatch) {
            const logTime = new Date(timestampMatch[0]);
            if (startDate && logTime < new Date(startDate)) return false;
            if (endDate && logTime > new Date(endDate)) return false;
          }
        }
        
        return true;
      });

      return {
        success: true,
        data: {
          filename,
          keyword,
          totalMatches: filteredLines.length,
          matches: filteredLines.slice(0, 1000) // é™åˆ¶è¿”å›æ•°é‡
        }
      };
    } catch (error) {
      this.logger.error(`æœç´¢æ—¥å¿—å¤±è´¥: ${error.message}`);
      throw error;
    }
  }

  /**
   * æ¸…ç†æ—§æ—¥å¿—æ–‡ä»¶
   */
  @Delete('cleanup')
  @ApiOperation({ summary: 'æ¸…ç†æ—§æ—¥å¿—æ–‡ä»¶' })
  async cleanupLogs(@Query('days') days: number = 30): Promise<any> {
    try {
      const logsDir = path.join(process.cwd(), 'logs');
      const files = await fs.readdir(logsDir);
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);

      let deletedCount = 0;
      let deletedSize = 0;

      for (const file of files) {
        if (!file.endsWith('.log')) continue;
        
        const filePath = path.join(logsDir, file);
        const stats = await fs.stat(filePath);
        
        if (stats.mtime < cutoffDate) {
          deletedSize += stats.size;
          await fs.remove(filePath);
          deletedCount++;
          this.logger.log(`åˆ é™¤æ—§æ—¥å¿—æ–‡ä»¶: ${file}`);
        }
      }

      return {
        success: true,
        data: {
          deletedCount,
          deletedSize,
          cutoffDate
        }
      };
    } catch (error) {
      this.logger.error(`æ¸…ç†æ—¥å¿—æ–‡ä»¶å¤±è´¥: ${error.message}`);
      throw new InternalServerErrorException('æ¸…ç†æ—¥å¿—æ–‡ä»¶å¤±è´¥');
    }
  }
}

// æ—¥å¿—æœç´¢DTO
class LogSearchDto {
  @IsOptional()
  @IsString()
  keyword?: string;

  @IsNotEmpty()
  @IsString()
  filename: string;

  @IsOptional()
  @IsDateString()
  startDate?: string;

  @IsOptional()
  @IsDateString()
  endDate?: string;

  @IsOptional()
  @IsIn(['error', 'warn', 'info', 'debug', 'verbose'])
  level?: string;
}
```

## ğŸš€ ä½¿ç”¨ç¤ºä¾‹

### åœ¨æœåŠ¡ä¸­ä½¿ç”¨æ—¥å¿—
```typescript
@Injectable()
export class ExampleService {
  private readonly logger = new CustomLogger('ExampleService');

  async performOperation(data: any): Promise<any> {
    const startTime = Date.now();
    
    try {
      this.logger.log(`å¼€å§‹æ‰§è¡Œæ“ä½œ - æ•°æ®: ${JSON.stringify(data)}`);
      
      // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
      const result = await this.doSomething(data);
      
      const duration = Date.now() - startTime;
      this.logger.performance('performOperation', duration);
      this.logger.business('æ“ä½œå®Œæˆ', { data, result });
      
      return result;
    } catch (error) {
      this.logger.error(`æ“ä½œå¤±è´¥: ${error.message}`, error.stack);
      throw error;
    }
  }
}
```

### ç¯å¢ƒå˜é‡é…ç½®
```env
# æ—¥å¿—é…ç½®
LOG_LEVEL=info
LOG_MAX_SIZE=20m
LOG_MAX_FILES=14d
```

---

**ç›¸å…³æ–‡æ¡£**:
- [ç³»ç»Ÿç›‘æ§æŒ‡å—](../06-è¿ç»´ç›‘æ§/ç³»ç»Ÿç›‘æ§æŒ‡å—.md)
- [æ•…éšœæ’æŸ¥æŒ‡å—](../06-è¿ç»´ç›‘æ§/æ•…éšœæ’æŸ¥.md)
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](../05-å¼€å‘æŒ‡å—/æ€§èƒ½ä¼˜åŒ–æŒ‡å—.md)
