# 📊 日志系统模块实现详解

## 📋 模块概述

日志系统模块是系统监控和调试的核心组件，提供结构化日志记录、日志轮转、追踪ID关联、性能监控等功能。采用Winston日志库，支持多种输出格式和存储方式。

## 🏗️ 模块架构

### 目录结构
```
backend-node/src/config/
├── logger.config.ts            # 日志配置
└── trace-id.config.ts          # 追踪ID配置

backend-node/src/common/
├── middleware/
│   └── trace-id.middleware.ts  # 追踪ID中间件
├── interceptors/
│   └── logging.interceptor.ts  # 日志拦截器
├── filters/
│   └── global-exception.filter.ts # 全局异常过滤器
└── controllers/
    └── logs.controller.ts      # 日志管理控制器
```

### 日志文件结构
```
logs/
├── backend.log                 # 当前日志文件
├── backend-2025-W28.log       # 按周轮转的日志
├── database.log               # 数据库日志
├── error.log                  # 错误日志
└── combined.log               # 综合日志
```

## 🔧 核心配置实现

### 日志配置 (LoggerConfig)
```typescript
import * as winston from 'winston';
import * as DailyRotateFile from 'winston-daily-rotate-file';
import { Injectable, LoggerService } from '@nestjs/common';

/**
 * 追踪ID管理器
 */
export class TraceIdManager {
  private static traceIdMap = new Map<string, string>();

  static generateTraceId(): string {
    return `trace_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }

  static setTraceId(key: string, traceId: string): void {
    this.traceIdMap.set(key, traceId);
  }

  static getTraceId(key: string): string | undefined {
    return this.traceIdMap.get(key);
  }

  static clearTraceId(key: string): void {
    this.traceIdMap.delete(key);
  }
}

/**
 * 自定义日志格式化器
 */
const customFormat = winston.format.combine(
  winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss.SSS'
  }),
  winston.format.errors({ stack: true }),
  winston.format.printf(({ timestamp, level, message, context, traceId, stack, ...meta }) => {
    const traceInfo = traceId ? `[${traceId}]` : '';
    const contextInfo = context ? `[${context}]` : '';
    const metaInfo = Object.keys(meta).length ? ` ${JSON.stringify(meta)}` : '';
    const stackInfo = stack ? `\n${stack}` : '';
    
    return `${timestamp} [${level.toUpperCase()}] ${traceInfo}${contextInfo} ${message}${metaInfo}${stackInfo}`;
  })
);

/**
 * 自定义Logger类
 */
@Injectable()
export class CustomLogger implements LoggerService {
  private readonly winston: winston.Logger;
  private context?: string;

  constructor(context?: string) {
    this.context = context;
    this.winston = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: customFormat,
      transports: [
        // 控制台输出
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            customFormat
          )
        }),

        // 应用日志文件（按日轮转）
        new DailyRotateFile({
          filename: 'logs/backend-%DATE%.log',
          datePattern: 'YYYY-[W]WW', // 按周轮转
          maxSize: '20m',
          maxFiles: '14d',
          format: customFormat,
          auditFile: 'logs/backend-audit.json'
        }),

        // 错误日志文件
        new DailyRotateFile({
          filename: 'logs/error-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          maxSize: '20m',
          maxFiles: '30d',
          level: 'error',
          format: customFormat
        }),

        // 综合日志文件
        new winston.transports.File({
          filename: 'logs/combined.log',
          maxsize: 50 * 1024 * 1024, // 50MB
          maxFiles: 5,
          format: customFormat
        })
      ],
      
      // 异常处理
      exceptionHandlers: [
        new winston.transports.File({ filename: 'logs/exceptions.log' })
      ],
      
      // 未捕获的Promise拒绝
      rejectionHandlers: [
        new winston.transports.File({ filename: 'logs/rejections.log' })
      ]
    });
  }

  /**
   * 记录普通日志
   */
  log(message: string, context?: string, traceId?: string): void {
    this.winston.info(message, {
      context: context || this.context,
      traceId
    });
  }

  /**
   * 记录错误日志
   */
  error(message: string, stack?: string, context?: string, traceId?: string): void {
    this.winston.error(message, {
      context: context || this.context,
      stack,
      traceId
    });
  }

  /**
   * 记录警告日志
   */
  warn(message: string, context?: string, traceId?: string): void {
    this.winston.warn(message, {
      context: context || this.context,
      traceId
    });
  }

  /**
   * 记录调试日志
   */
  debug(message: string, context?: string, traceId?: string): void {
    this.winston.debug(message, {
      context: context || this.context,
      traceId
    });
  }

  /**
   * 记录详细日志
   */
  verbose(message: string, context?: string, traceId?: string): void {
    this.winston.verbose(message, {
      context: context || this.context,
      traceId
    });
  }

  /**
   * 记录性能日志
   */
  performance(operation: string, duration: number, context?: string, traceId?: string): void {
    this.winston.info(`性能监控 - ${operation}: ${duration}ms`, {
      context: context || this.context,
      traceId,
      performance: {
        operation,
        duration,
        timestamp: new Date().toISOString()
      }
    });
  }

  /**
   * 记录业务日志
   */
  business(action: string, details: any, context?: string, traceId?: string): void {
    this.winston.info(`业务操作 - ${action}`, {
      context: context || this.context,
      traceId,
      business: {
        action,
        details,
        timestamp: new Date().toISOString()
      }
    });
  }
}

/**
 * 数据库日志记录器
 */
export class DatabaseLogger implements winston.Logger {
  private readonly winston: winston.Logger;

  constructor() {
    this.winston = winston.createLogger({
      level: 'info',
      format: customFormat,
      transports: [
        new DailyRotateFile({
          filename: 'logs/database-%DATE%.log',
          datePattern: 'YYYY-[W]WW',
          maxSize: '20m',
          maxFiles: '14d',
          format: customFormat
        })
      ]
    });
  }

  logQuery(query: string, parameters?: any[], queryRunner?: any): void {
    this.winston.info('SQL查询', {
      context: 'Database',
      query: query.replace(/\s+/g, ' ').trim(),
      parameters,
      duration: queryRunner?.duration || 0
    });
  }

  logQueryError(error: string, query: string, parameters?: any[], queryRunner?: any): void {
    this.winston.error('SQL查询错误', {
      context: 'Database',
      error,
      query: query.replace(/\s+/g, ' ').trim(),
      parameters,
      stack: error
    });
  }

  logQuerySlow(time: number, query: string, parameters?: any[], queryRunner?: any): void {
    this.winston.warn(`慢查询 - 耗时: ${time}ms`, {
      context: 'Database',
      query: query.replace(/\s+/g, ' ').trim(),
      parameters,
      duration: time
    });
  }

  logSchemaBuild(message: string, queryRunner?: any): void {
    this.winston.info(`数据库架构 - ${message}`, {
      context: 'Database'
    });
  }

  logMigration(message: string, queryRunner?: any): void {
    this.winston.info(`数据库迁移 - ${message}`, {
      context: 'Database'
    });
  }

  log(level: string, message: string, queryRunner?: any): void {
    this.winston.log(level, message, {
      context: 'Database'
    });
  }
}
```

## 🔍 追踪ID中间件

### 追踪ID中间件 (TraceIdMiddleware)
```typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { TraceIdManager } from '../../config/logger.config';

// 扩展Request接口
declare global {
  namespace Express {
    interface Request {
      traceId?: string;
    }
  }
}

/**
 * 请求追踪ID中间件
 * 为每个HTTP请求生成唯一的追踪ID，用于日志关联
 */
@Injectable()
export class TraceIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // 生成唯一的追踪ID
    const traceId = TraceIdManager.generateTraceId();
    
    // 将traceId添加到请求对象
    req.traceId = traceId;
    
    // 将traceId添加到响应头（便于调试）
    res.setHeader('X-Trace-Id', traceId);
    
    // 存储到TraceIdManager中
    TraceIdManager.setTraceId(req.url, traceId);
    
    // 请求结束时清理
    res.on('finish', () => {
      TraceIdManager.clearTraceId(req.url);
    });
    
    next();
  }
}
```

## 📊 日志拦截器

### 日志拦截器 (LoggingInterceptor)
```typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
import { Request, Response } from 'express';
import { CustomLogger } from '../../config/logger.config';

/**
 * 日志拦截器
 * 自动记录HTTP请求和响应的详细信息
 */
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new CustomLogger('HTTP');

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const ctx = context.switchToHttp();
    const request = ctx.getRequest<Request>();
    const response = ctx.getResponse<Response>();
    
    const { method, url, headers, body, query, params } = request;
    const traceId = request.traceId;
    const userAgent = headers['user-agent'] || '';
    const ip = this.getClientIp(request);
    const startTime = Date.now();

    // 记录请求开始日志
    this.logger.log(
      `请求开始 ${method} ${url}`,
      'HTTP',
      traceId
    );

    // 记录详细的请求信息（调试级别）
    if (process.env.NODE_ENV === 'development') {
      this.logger.debug(
        `请求详情 - IP: ${ip}, UserAgent: ${userAgent}, Query: ${JSON.stringify(query)}, Body: ${JSON.stringify(this.sanitizeBody(body))}`,
        'HTTP',
        traceId
      );
    }

    return next.handle().pipe(
      tap((data) => {
        // 请求成功完成
        const duration = Date.now() - startTime;
        const statusCode = response.statusCode;
        
        this.logger.log(
          `请求完成 ${method} ${url} - ${statusCode} - ${duration}ms`,
          'HTTP',
          traceId
        );

        // 记录性能日志
        if (duration > 1000) {
          this.logger.performance(
            `${method} ${url}`,
            duration,
            'HTTP',
            traceId
          );
        }

        // 记录响应详情（仅在调试模式）
        if (process.env.NODE_ENV === 'development') {
          this.logger.debug(
            `响应详情 - 状态码: ${statusCode}, 耗时: ${duration}ms, 数据大小: ${JSON.stringify(data).length} bytes`,
            'HTTP',
            traceId
          );
        }
      }),
      catchError((error) => {
        // 请求处理出错
        const duration = Date.now() - startTime;
        const statusCode = error.status || 500;
        
        this.logger.error(
          `请求失败 ${method} ${url} - ${statusCode} - ${duration}ms - ${error.message}`,
          error.stack,
          'HTTP',
          traceId
        );

        // 重新抛出错误，让全局异常过滤器处理
        throw error;
      })
    );
  }

  /**
   * 获取客户端IP地址
   */
  private getClientIp(request: Request): string {
    return (
      request.headers['x-forwarded-for'] as string ||
      request.headers['x-real-ip'] as string ||
      request.connection.remoteAddress ||
      request.socket.remoteAddress ||
      'unknown'
    );
  }

  /**
   * 清理敏感信息
   */
  private sanitizeBody(body: any): any {
    if (!body || typeof body !== 'object') {
      return body;
    }

    const sensitiveFields = ['password', 'token', 'secret', 'key'];
    const sanitized = { ...body };

    for (const field of sensitiveFields) {
      if (sanitized[field]) {
        sanitized[field] = '***';
      }
    }

    return sanitized;
  }
}
```

## 🚨 全局异常过滤器

### 全局异常过滤器 (GlobalExceptionFilter)
```typescript
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { CustomLogger } from '../../config/logger.config';

/**
 * 全局异常过滤器
 * 统一处理所有未捕获的异常，提供一致的错误响应格式
 */
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new CustomLogger('GlobalExceptionFilter');

  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // 使用请求中的追踪ID
    const traceId = (request as any).traceId || this.generateTraceId();

    // 解析异常信息
    const exceptionInfo = this.parseException(exception);

    // 记录异常日志
    this.logException(exception, request, traceId, exceptionInfo);

    // 构建响应数据
    const responseData = this.buildErrorResponse(exceptionInfo, request, traceId);

    // 返回统一格式的错误响应
    response.status(exceptionInfo.httpStatus).json(responseData);
  }

  /**
   * 解析异常信息
   */
  private parseException(exception: unknown): ExceptionInfo {
    if (exception instanceof HttpException) {
      return {
        httpStatus: exception.getStatus(),
        message: exception.message,
        name: exception.constructor.name,
        stack: exception.stack,
        details: exception.getResponse()
      };
    }

    if (exception instanceof Error) {
      return {
        httpStatus: HttpStatus.INTERNAL_SERVER_ERROR,
        message: exception.message || '内部服务器错误',
        name: exception.constructor.name,
        stack: exception.stack,
        details: null
      };
    }

    return {
      httpStatus: HttpStatus.INTERNAL_SERVER_ERROR,
      message: '未知错误',
      name: 'UnknownError',
      stack: null,
      details: exception
    };
  }

  /**
   * 记录异常日志
   */
  private logException(
    exception: unknown,
    request: Request,
    traceId: string,
    exceptionInfo: ExceptionInfo
  ): void {
    const { method, url, headers, body } = request;
    const userAgent = headers['user-agent'] || '';
    const ip = this.getClientIp(request);

    // 构建日志消息
    const logMessage = `异常捕获 ${method} ${url} - ${exceptionInfo.httpStatus} - ${exceptionInfo.message}`;
    
    // 构建详细信息
    const logDetails = {
      exception: {
        name: exceptionInfo.name,
        message: exceptionInfo.message,
        httpStatus: exceptionInfo.httpStatus
      },
      request: {
        method,
        url,
        ip,
        userAgent,
        body: this.sanitizeBody(body)
      },
      timestamp: new Date().toISOString()
    };

    // 根据异常类型选择日志级别
    if (exceptionInfo.httpStatus >= 500) {
      // 服务器错误 - ERROR级别
      this.logger.error(
        logMessage,
        exceptionInfo.stack,
        'GlobalExceptionFilter',
        traceId
      );
    } else if (exceptionInfo.httpStatus >= 400) {
      // 客户端错误 - WARN级别
      this.logger.warn(
        logMessage,
        'GlobalExceptionFilter',
        traceId
      );
    } else {
      // 其他情况 - INFO级别
      this.logger.log(
        logMessage,
        'GlobalExceptionFilter',
        traceId
      );
    }

    // 记录详细的异常信息（调试模式）
    if (process.env.NODE_ENV === 'development') {
      this.logger.debug(
        `异常详情: ${JSON.stringify(logDetails, null, 2)}`,
        'GlobalExceptionFilter',
        traceId
      );
    }
  }

  /**
   * 构建错误响应
   */
  private buildErrorResponse(
    exceptionInfo: ExceptionInfo,
    request: Request,
    traceId: string
  ): any {
    const baseResponse = {
      success: false,
      code: exceptionInfo.httpStatus,
      message: exceptionInfo.message,
      timestamp: new Date().toISOString(),
      path: request.url,
      traceId
    };

    // 开发环境返回更多调试信息
    if (process.env.NODE_ENV === 'development') {
      return {
        ...baseResponse,
        error: exceptionInfo.name,
        details: exceptionInfo.details,
        stack: exceptionInfo.stack
      };
    }

    return baseResponse;
  }

  /**
   * 获取客户端IP
   */
  private getClientIp(request: Request): string {
    return (
      request.headers['x-forwarded-for'] as string ||
      request.headers['x-real-ip'] as string ||
      request.connection.remoteAddress ||
      'unknown'
    );
  }

  /**
   * 清理敏感信息
   */
  private sanitizeBody(body: any): any {
    if (!body || typeof body !== 'object') {
      return body;
    }

    const sensitiveFields = ['password', 'token', 'secret', 'key'];
    const sanitized = { ...body };

    for (const field of sensitiveFields) {
      if (sanitized[field]) {
        sanitized[field] = '***';
      }
    }

    return sanitized;
  }

  /**
   * 生成追踪ID
   */
  private generateTraceId(): string {
    return `trace_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }
}

interface ExceptionInfo {
  httpStatus: number;
  message: string;
  name: string;
  stack?: string;
  details?: any;
}
```

## 📋 日志管理控制器

### 日志管理控制器 (LogsController)
```typescript
@ApiTags('日志管理')
@Controller('logs')
@UseGuards(JwtAuthGuard, AdminGuard)
export class LogsController {
  private readonly logger = new CustomLogger('LogsController');

  /**
   * 获取日志文件列表
   */
  @Get('files')
  @ApiOperation({ summary: '获取日志文件列表' })
  async getLogFiles(): Promise<any> {
    try {
      const logsDir = path.join(process.cwd(), 'logs');
      const files = await fs.readdir(logsDir);
      
      const logFiles = await Promise.all(
        files
          .filter(file => file.endsWith('.log'))
          .map(async (file) => {
            const filePath = path.join(logsDir, file);
            const stats = await fs.stat(filePath);
            
            return {
              name: file,
              size: stats.size,
              modified: stats.mtime,
              created: stats.birthtime
            };
          })
      );

      return {
        success: true,
        data: logFiles.sort((a, b) => b.modified.getTime() - a.modified.getTime())
      };
    } catch (error) {
      this.logger.error(`获取日志文件列表失败: ${error.message}`);
      throw new InternalServerErrorException('获取日志文件列表失败');
    }
  }

  /**
   * 读取日志文件内容
   */
  @Get('files/:filename')
  @ApiOperation({ summary: '读取日志文件内容' })
  async readLogFile(
    @Param('filename') filename: string,
    @Query('lines') lines: number = 100,
    @Query('offset') offset: number = 0
  ): Promise<any> {
    try {
      const logsDir = path.join(process.cwd(), 'logs');
      const filePath = path.join(logsDir, filename);

      // 安全检查：确保文件在logs目录内
      if (!filePath.startsWith(logsDir)) {
        throw new BadRequestException('无效的文件路径');
      }

      // 检查文件是否存在
      if (!await fs.pathExists(filePath)) {
        throw new NotFoundException('日志文件不存在');
      }

      // 读取文件内容
      const content = await fs.readFile(filePath, 'utf-8');
      const allLines = content.split('\n');
      
      // 分页处理
      const startIndex = Math.max(0, allLines.length - lines - offset);
      const endIndex = allLines.length - offset;
      const selectedLines = allLines.slice(startIndex, endIndex);

      return {
        success: true,
        data: {
          filename,
          totalLines: allLines.length,
          lines: selectedLines,
          hasMore: startIndex > 0
        }
      };
    } catch (error) {
      this.logger.error(`读取日志文件失败: ${error.message}`);
      throw error;
    }
  }

  /**
   * 搜索日志内容
   */
  @Post('search')
  @ApiOperation({ summary: '搜索日志内容' })
  async searchLogs(@Body() searchDto: LogSearchDto): Promise<any> {
    try {
      const { keyword, filename, startDate, endDate, level } = searchDto;
      const logsDir = path.join(process.cwd(), 'logs');
      const filePath = path.join(logsDir, filename);

      if (!await fs.pathExists(filePath)) {
        throw new NotFoundException('日志文件不存在');
      }

      const content = await fs.readFile(filePath, 'utf-8');
      const lines = content.split('\n');
      
      // 过滤日志行
      const filteredLines = lines.filter(line => {
        if (!line.trim()) return false;
        
        // 关键词搜索
        if (keyword && !line.toLowerCase().includes(keyword.toLowerCase())) {
          return false;
        }
        
        // 日志级别过滤
        if (level && !line.includes(`[${level.toUpperCase()}]`)) {
          return false;
        }
        
        // 时间范围过滤（简单实现）
        if (startDate || endDate) {
          const timestampMatch = line.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/);
          if (timestampMatch) {
            const logTime = new Date(timestampMatch[0]);
            if (startDate && logTime < new Date(startDate)) return false;
            if (endDate && logTime > new Date(endDate)) return false;
          }
        }
        
        return true;
      });

      return {
        success: true,
        data: {
          filename,
          keyword,
          totalMatches: filteredLines.length,
          matches: filteredLines.slice(0, 1000) // 限制返回数量
        }
      };
    } catch (error) {
      this.logger.error(`搜索日志失败: ${error.message}`);
      throw error;
    }
  }

  /**
   * 清理旧日志文件
   */
  @Delete('cleanup')
  @ApiOperation({ summary: '清理旧日志文件' })
  async cleanupLogs(@Query('days') days: number = 30): Promise<any> {
    try {
      const logsDir = path.join(process.cwd(), 'logs');
      const files = await fs.readdir(logsDir);
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);

      let deletedCount = 0;
      let deletedSize = 0;

      for (const file of files) {
        if (!file.endsWith('.log')) continue;
        
        const filePath = path.join(logsDir, file);
        const stats = await fs.stat(filePath);
        
        if (stats.mtime < cutoffDate) {
          deletedSize += stats.size;
          await fs.remove(filePath);
          deletedCount++;
          this.logger.log(`删除旧日志文件: ${file}`);
        }
      }

      return {
        success: true,
        data: {
          deletedCount,
          deletedSize,
          cutoffDate
        }
      };
    } catch (error) {
      this.logger.error(`清理日志文件失败: ${error.message}`);
      throw new InternalServerErrorException('清理日志文件失败');
    }
  }
}

// 日志搜索DTO
class LogSearchDto {
  @IsOptional()
  @IsString()
  keyword?: string;

  @IsNotEmpty()
  @IsString()
  filename: string;

  @IsOptional()
  @IsDateString()
  startDate?: string;

  @IsOptional()
  @IsDateString()
  endDate?: string;

  @IsOptional()
  @IsIn(['error', 'warn', 'info', 'debug', 'verbose'])
  level?: string;
}
```

## 🚀 使用示例

### 在服务中使用日志
```typescript
@Injectable()
export class ExampleService {
  private readonly logger = new CustomLogger('ExampleService');

  async performOperation(data: any): Promise<any> {
    const startTime = Date.now();
    
    try {
      this.logger.log(`开始执行操作 - 数据: ${JSON.stringify(data)}`);
      
      // 执行业务逻辑
      const result = await this.doSomething(data);
      
      const duration = Date.now() - startTime;
      this.logger.performance('performOperation', duration);
      this.logger.business('操作完成', { data, result });
      
      return result;
    } catch (error) {
      this.logger.error(`操作失败: ${error.message}`, error.stack);
      throw error;
    }
  }
}
```

### 环境变量配置
```env
# 日志配置
LOG_LEVEL=info
LOG_MAX_SIZE=20m
LOG_MAX_FILES=14d
```

---

**相关文档**:
- [系统监控指南](../06-运维监控/系统监控指南.md)
- [故障排查指南](../06-运维监控/故障排查.md)
- [性能优化指南](../05-开发指南/性能优化指南.md)
