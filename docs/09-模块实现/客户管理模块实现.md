# ğŸ¢ å®¢æˆ·ç®¡ç†æ¨¡å—å®ç°è¯¦è§£

## ğŸ“‹ æ¨¡å—æ¦‚è¿°

å®¢æˆ·ç®¡ç†æ¨¡å—æ˜¯ç‰©æµé…é€ç³»ç»Ÿçš„æ ¸å¿ƒä¸šåŠ¡æ¨¡å—ï¼Œè´Ÿè´£ç®¡ç†å®¢æˆ·ä¿¡æ¯ã€åœ°å€ä¿¡æ¯ã€åœ°ç†ä½ç½®ç­‰æ•°æ®ã€‚æ”¯æŒå¤šæ¡ä»¶æœç´¢ã€æ‰¹é‡æ“ä½œã€åœ°ç†ç¼–ç ç­‰åŠŸèƒ½ã€‚

## ğŸ—ï¸ æ¨¡å—æ¶æ„

### ç›®å½•ç»“æ„
```
backend-node/src/customers/
â”œâ”€â”€ customers.controller.ts     # å®¢æˆ·æ§åˆ¶å™¨
â”œâ”€â”€ customers.service.ts        # å®¢æˆ·æœåŠ¡
â”œâ”€â”€ customers.module.ts         # å®¢æˆ·æ¨¡å—
â”œâ”€â”€ entities/
â”‚   â””â”€â”€ customer.entity.ts      # å®¢æˆ·å®ä½“
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-customer.dto.ts  # åˆ›å»ºå®¢æˆ·DTO
â”‚   â”œâ”€â”€ update-customer.dto.ts  # æ›´æ–°å®¢æˆ·DTO
â”‚   â”œâ”€â”€ search-customer.dto.ts  # æœç´¢å®¢æˆ·DTO
â”‚   â”œâ”€â”€ sync-customer.dto.ts    # åŒæ­¥å®¢æˆ·DTO
â”‚   â””â”€â”€ wx-update-customer.dto.ts # å°ç¨‹åºæ›´æ–°DTO
â””â”€â”€ interfaces/
    â””â”€â”€ customer.interface.ts   # å®¢æˆ·æ¥å£å®šä¹‰
```

### å‰ç«¯ç»“æ„
```
admin-frontend/src/app/customer/
â”œâ”€â”€ page.tsx                    # å®¢æˆ·ç®¡ç†é¡µé¢
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ CustomerTable.tsx       # å®¢æˆ·è¡¨æ ¼ç»„ä»¶
â”‚   â”œâ”€â”€ CustomerForm.tsx        # å®¢æˆ·è¡¨å•ç»„ä»¶
â”‚   â”œâ”€â”€ SearchForm.tsx          # æœç´¢è¡¨å•ç»„ä»¶
â”‚   â””â”€â”€ BatchOperations.tsx     # æ‰¹é‡æ“ä½œç»„ä»¶
â””â”€â”€ hooks/
    â””â”€â”€ useCustomers.tsx        # å®¢æˆ·æ•°æ®Hook
```

## ğŸ—„ï¸ æ•°æ®å®ä½“è®¾è®¡

### å®¢æˆ·å®ä½“ (Customer)
```typescript
@Entity('t_customers')
export class Customer {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ name: 'customerNumber', length: 50, unique: true })
  customerNumber: string;

  @Column({ name: 'customerName', length: 100 })
  customerName: string;

  @Column({ name: 'storeAddress', length: 255, nullable: true })
  storeAddress: string;

  @Column({ name: 'warehouseAddress', length: 255, nullable: true })
  warehouseAddress: string;

  @Column({ name: 'storeLongitude', type: 'decimal', precision: 10, scale: 7, nullable: true })
  storeLongitude: number;

  @Column({ name: 'storeLatitude', type: 'decimal', precision: 10, scale: 7, nullable: true })
  storeLatitude: number;

  @Column({ name: 'warehouseLongitude', type: 'decimal', precision: 10, scale: 7, nullable: true })
  warehouseLongitude: number;

  @Column({ name: 'warehouseLatitude', type: 'decimal', precision: 10, scale: 7, nullable: true })
  warehouseLatitude: number;

  @Column({ name: 'lastSyncTime', type: 'datetime', nullable: true })
  lastSyncTime: Date;

  @Column({ name: 'is_deleted', type: 'tinyint', width: 1, default: 0 })
  isDeleted: number;

  @Column({ name: 'updateBy', length: 50, nullable: true })
  updateBy: string;

  @CreateDateColumn({ name: 'createdAt' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updatedAt' })
  updatedAt: Date;
}
```

## ğŸ” æ ¸å¿ƒæœåŠ¡å®ç°

### å®¢æˆ·æœåŠ¡ (CustomersService)
```typescript
@Injectable()
export class CustomersService {
  private readonly logger = new CustomLogger('CustomersService');

  constructor(
    @InjectRepository(Customer)
    private customerRepository: Repository<Customer>,
  ) {}

  /**
   * åˆ†é¡µæŸ¥è¯¢å®¢æˆ·åˆ—è¡¨
   */
  async findAll(page: number = 1, limit: number = 10, user?: any): Promise<PaginatedResponse<Customer>> {
    const skip = (page - 1) * limit;

    const [customers, total] = await this.customerRepository.findAndCount({
      where: { isDeleted: 0 },
      skip,
      take: limit,
      order: { createdAt: 'DESC' },
    });

    this.logger.log(`æŸ¥è¯¢å®¢æˆ·åˆ—è¡¨ - é¡µç : ${page}, æ¯é¡µ: ${limit}, æ€»æ•°: ${total}, ç”¨æˆ·: ${user?.id || 'æœªçŸ¥'}`);

    return {
      data: customers,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  /**
   * å¤šæ¡ä»¶æœç´¢å®¢æˆ·
   */
  async search(searchDto: SearchCustomerDto, user?: any): Promise<PaginatedResponse<Customer>> {
    const { keyword, customerNumber, customerName, page = 1, limit = 10 } = searchDto;
    const skip = (page - 1) * limit;

    const queryBuilder = this.customerRepository.createQueryBuilder('customer')
      .where('customer.isDeleted = :isDeleted', { isDeleted: 0 });

    // å…³é”®è¯æœç´¢ï¼ˆå®¢æˆ·ç¼–å·ã€åç§°ã€åœ°å€ï¼‰
    if (keyword) {
      queryBuilder.andWhere(
        '(customer.customerNumber LIKE :keyword OR customer.customerName LIKE :keyword OR customer.storeAddress LIKE :keyword OR customer.warehouseAddress LIKE :keyword)',
        { keyword: `%${keyword}%` }
      );
    }

    // ç²¾ç¡®æœç´¢å®¢æˆ·ç¼–å·
    if (customerNumber) {
      queryBuilder.andWhere('customer.customerNumber = :customerNumber', { customerNumber });
    }

    // æ¨¡ç³Šæœç´¢å®¢æˆ·åç§°
    if (customerName) {
      queryBuilder.andWhere('customer.customerName LIKE :customerName', { customerName: `%${customerName}%` });
    }

    // åˆ†é¡µå’Œæ’åº
    queryBuilder
      .skip(skip)
      .take(limit)
      .orderBy('customer.createdAt', 'DESC');

    const [customers, total] = await queryBuilder.getManyAndCount();

    this.logger.log(`æœç´¢å®¢æˆ· - å…³é”®è¯: ${keyword}, å®¢æˆ·ç¼–å·: ${customerNumber}, å®¢æˆ·åç§°: ${customerName}, ç»“æœæ•°: ${customers.length}, ç”¨æˆ·: ${user?.id || 'æœªçŸ¥'}`);

    return {
      data: customers,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  /**
   * åˆ›å»ºå®¢æˆ·
   */
  async create(createCustomerDto: CreateCustomerDto, user?: any): Promise<Customer> {
    // ç”Ÿæˆå®¢æˆ·ç¼–å·
    const customerNumber = await this.generateCustomerNumber();

    const customer = this.customerRepository.create({
      ...createCustomerDto,
      customerNumber,
      updateBy: user?.username || 'system',
    });

    const savedCustomer = await this.customerRepository.save(customer);
    
    this.logger.log(`åˆ›å»ºå®¢æˆ·æˆåŠŸ - ID: ${savedCustomer.id}, ç¼–å·: ${customerNumber}, åç§°: ${createCustomerDto.customerName}, æ“ä½œäºº: ${user?.username || 'ç³»ç»Ÿ'}`);

    return savedCustomer;
  }

  /**
   * æ›´æ–°å®¢æˆ·ä¿¡æ¯
   */
  async update(id: number, updateCustomerDto: UpdateCustomerDto, user?: any): Promise<Customer> {
    const customer = await this.findOne(id);

    // æ›´æ–°å®¢æˆ·ä¿¡æ¯
    Object.assign(customer, {
      ...updateCustomerDto,
      updateBy: user?.username || 'system',
    });

    const updatedCustomer = await this.customerRepository.save(customer);
    
    this.logger.log(`æ›´æ–°å®¢æˆ·æˆåŠŸ - ID: ${id}, ç¼–å·: ${customer.customerNumber}, æ“ä½œäºº: ${user?.username || 'ç³»ç»Ÿ'}`);

    return updatedCustomer;
  }

  /**
   * åˆ é™¤å®¢æˆ·ï¼ˆè½¯åˆ é™¤ï¼‰
   */
  async remove(id: number, user?: any): Promise<void> {
    const customer = await this.findOne(id);

    await this.customerRepository.update(id, {
      isDeleted: 1,
      updateBy: user?.username || 'system',
    });

    this.logger.log(`åˆ é™¤å®¢æˆ·æˆåŠŸ - ID: ${id}, ç¼–å·: ${customer.customerNumber}, æ“ä½œäºº: ${user?.username || 'ç³»ç»Ÿ'}`);
  }

  /**
   * æ‰¹é‡åˆ é™¤å®¢æˆ·
   */
  async batchRemove(ids: number[], user?: any): Promise<void> {
    await this.customerRepository.update(
      { id: In(ids) },
      {
        isDeleted: 1,
        updateBy: user?.username || 'system',
      }
    );

    this.logger.log(`æ‰¹é‡åˆ é™¤å®¢æˆ·æˆåŠŸ - æ•°é‡: ${ids.length}, æ“ä½œäºº: ${user?.username || 'ç³»ç»Ÿ'}`);
  }

  /**
   * åœ°ç†ç¼–ç  - åœ°å€è½¬åæ ‡
   */
  async geocodeAddress(geocodeDto: GeocodeRequestDto): Promise<GeocodeResponse> {
    const { address } = geocodeDto;
    
    try {
      // è°ƒç”¨é«˜å¾·åœ°å›¾APIè¿›è¡Œåœ°ç†ç¼–ç 
      const response = await axios.get('https://restapi.amap.com/v3/geocode/geo', {
        params: {
          key: process.env.AMAP_API_KEY || 'your-amap-api-key',
          address: address,
          output: 'json',
        },
      });

      if (response.data.status === '1' && response.data.geocodes.length > 0) {
        const geocode = response.data.geocodes[0];
        const [longitude, latitude] = geocode.location.split(',').map(Number);

        this.logger.log(`åœ°ç†ç¼–ç æˆåŠŸ - åœ°å€: ${address}, åæ ‡: ${longitude}, ${latitude}`);

        return {
          address,
          longitude,
          latitude,
          formattedAddress: geocode.formatted_address,
          province: geocode.province,
          city: geocode.city,
          district: geocode.district,
        };
      } else {
        throw new Error('åœ°ç†ç¼–ç å¤±è´¥ï¼šæœªæ‰¾åˆ°å¯¹åº”åæ ‡');
      }
    } catch (error) {
      this.logger.error(`åœ°ç†ç¼–ç å¤±è´¥ - åœ°å€: ${address}, é”™è¯¯: ${error.message}`);
      throw new Error(`åœ°ç†ç¼–ç å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * é€†åœ°ç†ç¼–ç  - åæ ‡è½¬åœ°å€
   */
  async reverseGeocode(reverseGeocodeDto: ReverseGeocodeRequestDto): Promise<ReverseGeocodeResponse> {
    const { longitude, latitude } = reverseGeocodeDto;
    
    try {
      const response = await axios.get('https://restapi.amap.com/v3/geocode/regeo', {
        params: {
          key: process.env.AMAP_API_KEY || 'your-amap-api-key',
          location: `${longitude},${latitude}`,
          output: 'json',
          radius: 1000,
          extensions: 'base',
        },
      });

      if (response.data.status === '1') {
        const regeocode = response.data.regeocode;
        
        this.logger.log(`é€†åœ°ç†ç¼–ç æˆåŠŸ - åæ ‡: ${longitude}, ${latitude}, åœ°å€: ${regeocode.formatted_address}`);

        return {
          longitude,
          latitude,
          formattedAddress: regeocode.formatted_address,
          province: regeocode.addressComponent.province,
          city: regeocode.addressComponent.city,
          district: regeocode.addressComponent.district,
          street: regeocode.addressComponent.streetNumber?.street || '',
          streetNumber: regeocode.addressComponent.streetNumber?.number || '',
        };
      } else {
        throw new Error('é€†åœ°ç†ç¼–ç å¤±è´¥ï¼šæœªæ‰¾åˆ°å¯¹åº”åœ°å€');
      }
    } catch (error) {
      this.logger.error(`é€†åœ°ç†ç¼–ç å¤±è´¥ - åæ ‡: ${longitude}, ${latitude}, é”™è¯¯: ${error.message}`);
      throw new Error(`é€†åœ°ç†ç¼–ç å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * ç”Ÿæˆå®¢æˆ·ç¼–å·
   */
  private async generateCustomerNumber(): Promise<string> {
    const lastCustomer = await this.customerRepository.findOne({
      where: { isDeleted: 0 },
      order: { id: 'DESC' },
    });

    let nextNumber = 1;
    if (lastCustomer && lastCustomer.customerNumber) {
      const match = lastCustomer.customerNumber.match(/C(\d+)/);
      if (match) {
        nextNumber = parseInt(match[1]) + 1;
      }
    }

    return `C${nextNumber.toString().padStart(3, '0')}`;
  }

  /**
   * æ ¹æ®IDæŸ¥æ‰¾å®¢æˆ·
   */
  async findOne(id: number): Promise<Customer> {
    const customer = await this.customerRepository.findOne({
      where: { id, isDeleted: 0 },
    });

    if (!customer) {
      throw new NotFoundException(`å®¢æˆ·ä¸å­˜åœ¨ (ID: ${id})`);
    }

    return customer;
  }
}
```

## ğŸ¯ æ§åˆ¶å™¨å®ç°

### å®¢æˆ·æ§åˆ¶å™¨ (CustomersController)
```typescript
@ApiTags('å®¢æˆ·ç®¡ç†')
@Controller('customers')
@UseGuards(JwtAuthGuard)
export class CustomersController {
  private readonly logger = new CustomLogger('CustomersController');

  constructor(private readonly customersService: CustomersService) {}

  @Get()
  @ApiOperation({ summary: 'è·å–å®¢æˆ·åˆ—è¡¨' })
  async findAll(
    @Query('page') page: number = 1,
    @Query('limit') limit: number = 10,
    @Req() req,
  ) {
    return this.customersService.findAll(page, limit, req.user);
  }

  @Get('search')
  @ApiOperation({ summary: 'æœç´¢å®¢æˆ·' })
  async search(@Query() searchDto: SearchCustomerDto, @Req() req) {
    return this.customersService.search(searchDto, req.user);
  }

  @Get(':id')
  @ApiOperation({ summary: 'è·å–å®¢æˆ·è¯¦æƒ…' })
  async findOne(@Param('id') id: string) {
    return this.customersService.findOne(+id);
  }

  @Post()
  @ApiOperation({ summary: 'åˆ›å»ºå®¢æˆ·' })
  async create(@Body() createCustomerDto: CreateCustomerDto, @Req() req) {
    return this.customersService.create(createCustomerDto, req.user);
  }

  @Put(':id')
  @ApiOperation({ summary: 'æ›´æ–°å®¢æˆ·' })
  async update(
    @Param('id') id: string,
    @Body() updateCustomerDto: UpdateCustomerDto,
    @Req() req,
  ) {
    return this.customersService.update(+id, updateCustomerDto, req.user);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'åˆ é™¤å®¢æˆ·' })
  async remove(@Param('id') id: string, @Req() req) {
    return this.customersService.remove(+id, req.user);
  }

  @Delete('batch')
  @ApiOperation({ summary: 'æ‰¹é‡åˆ é™¤å®¢æˆ·' })
  async batchRemove(@Body() { ids }: { ids: number[] }, @Req() req) {
    return this.customersService.batchRemove(ids, req.user);
  }

  @Post('geocode')
  @ApiOperation({ summary: 'åœ°ç†ç¼–ç ' })
  async geocode(@Body() geocodeDto: GeocodeRequestDto) {
    return this.customersService.geocodeAddress(geocodeDto);
  }

  @Post('reverse-geocode')
  @ApiOperation({ summary: 'é€†åœ°ç†ç¼–ç ' })
  async reverseGeocode(@Body() reverseGeocodeDto: ReverseGeocodeRequestDto) {
    return this.customersService.reverseGeocode(reverseGeocodeDto);
  }
}
```

## ğŸ¨ å‰ç«¯å®ç°

### å®¢æˆ·ç®¡ç†é¡µé¢
```typescript
export default function CustomerPage() {
  const [customers, setCustomers] = useState<Customer[]>([]);
  const [loading, setLoading] = useState(false);
  const [pagination, setPagination] = useState({
    current: 1,
    pageSize: 10,
    total: 0,
  });

  const fetchCustomers = async (page = 1, limit = 10, searchParams = {}) => {
    setLoading(true);
    try {
      const response = await api.get('/customers', {
        params: { page, limit, ...searchParams },
      });
      
      setCustomers(response.data.data);
      setPagination({
        current: response.data.page,
        pageSize: response.data.limit,
        total: response.data.total,
      });
    } catch (error) {
      console.error('è·å–å®¢æˆ·åˆ—è¡¨å¤±è´¥:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchCustomers();
  }, []);

  return (
    <div className="customer-management">
      <div className="header">
        <h1>å®¢æˆ·ç®¡ç†</h1>
        <Button type="primary" onClick={() => setShowCreateModal(true)}>
          æ–°å¢å®¢æˆ·
        </Button>
      </div>

      <SearchForm onSearch={fetchCustomers} />
      
      <CustomerTable
        customers={customers}
        loading={loading}
        pagination={pagination}
        onPageChange={fetchCustomers}
        onEdit={handleEdit}
        onDelete={handleDelete}
      />

      <CustomerForm
        visible={showCreateModal}
        onCancel={() => setShowCreateModal(false)}
        onSuccess={() => {
          setShowCreateModal(false);
          fetchCustomers();
        }}
      />
    </div>
  );
}
```

## ğŸ“Š æ•°æ®ä¼ è¾“å¯¹è±¡ (DTO)

### æœç´¢å®¢æˆ·DTO
```typescript
export class SearchCustomerDto {
  @ApiProperty({ description: 'å…³é”®è¯æœç´¢', required: false })
  @IsOptional()
  @IsString()
  keyword?: string;

  @ApiProperty({ description: 'å®¢æˆ·ç¼–å·', required: false })
  @IsOptional()
  @IsString()
  customerNumber?: string;

  @ApiProperty({ description: 'å®¢æˆ·åç§°', required: false })
  @IsOptional()
  @IsString()
  customerName?: string;

  @ApiProperty({ description: 'é¡µç ', required: false, default: 1 })
  @IsOptional()
  @IsInt()
  @Min(1)
  page?: number = 1;

  @ApiProperty({ description: 'æ¯é¡µæ•°é‡', required: false, default: 10 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(100)
  limit?: number = 10;
}
```

### åˆ›å»ºå®¢æˆ·DTO
```typescript
export class CreateCustomerDto {
  @ApiProperty({ description: 'å®¢æˆ·åç§°' })
  @IsNotEmpty()
  @IsString()
  @MaxLength(100)
  customerName: string;

  @ApiProperty({ description: 'é—¨åº—åœ°å€', required: false })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  storeAddress?: string;

  @ApiProperty({ description: 'ä»“åº“åœ°å€', required: false })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  warehouseAddress?: string;

  @ApiProperty({ description: 'é—¨åº—ç»åº¦', required: false })
  @IsOptional()
  @IsNumber()
  storeLongitude?: number;

  @ApiProperty({ description: 'é—¨åº—çº¬åº¦', required: false })
  @IsOptional()
  @IsNumber()
  storeLatitude?: number;

  @ApiProperty({ description: 'ä»“åº“ç»åº¦', required: false })
  @IsOptional()
  @IsNumber()
  warehouseLongitude?: number;

  @ApiProperty({ description: 'ä»“åº“çº¬åº¦', required: false })
  @IsOptional()
  @IsNumber()
  warehouseLatitude?: number;
}
```

---

**ç›¸å…³æ–‡æ¡£**:
- [å°ç¨‹åºå®¢æˆ·åŠŸèƒ½](./å°ç¨‹åºå®¢æˆ·æ¨¡å—å®ç°.md)
- [åœ°ç†ç¼–ç æœåŠ¡](./åœ°ç†ç¼–ç æ¨¡å—å®ç°.md)
- [æ•°æ®åº“è®¾è®¡](../01-æ¶æ„è®¾è®¡/æ•°æ®åº“è®¾è®¡.md)
